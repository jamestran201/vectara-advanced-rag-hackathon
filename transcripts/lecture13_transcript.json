{"documentId": "lecture13", "section": [{"text": "Okay, thank you. Okay, so good afternoon, good evening, good morning, good night, wherever you are. We're going to talk today about transactions, and you probably noticed the reading material for today is a little bit more tutorial in nature. We're not studying a particular system and see how a set of ids are implemented in that set of in that system. Instead, what we're going to be doing is talking about just the concept of transactions because it shows up in the next two papers that we'll be studying.", "metadataJson": "{\"start\":0,\"end\":34}"}, {"text": "And those two papers have quite a lot of material in them. And assume that you're familiar with transactions in particular, that you're familiar with the two core ideas that we'll see in today's lecture, namely two phase locking and two phase commit.", "metadataJson": "{\"start\":35,\"end\":58}"}, {"text": "And sometimes they are abbreviated as, you know, two pc or two phase commit and two pl for two phase locking. One point of confusion that the two terms really don't have to do much. Don't have, don't do are really not that much related. They happen to have both the two warts two phase in it, but they solve completely different problems. They happen to also show up typically in the context of transactions.", "metadataJson": "{\"start\":66,\"end\":96}"}, {"text": "But even outside of transactions, they are good ideas or worthy ideas. Don't let yourself confused by the fact that they both have two phase in it. They're pretty unrelated. Okay, so I'm just going to dive in a little bit and start talking about transactions in general. And the reason that we're going to care about transactions a lot is that we want to be able to do cross machine operations.", "metadataJson": "{\"start\":96,\"end\":125}"}, {"text": "So the problem that we're going to try to tackle in this lecture, as well as in the two upcoming papers is cross machine atomic ops.", "metadataJson": "{\"start\":126,\"end\":142}"}, {"text": "And so for example, just to make it a little bit concrete, let's say we have a client, we have two, we have a sharded key value server. So some of the keys are on key value server one, some are on key value server two. So the keys are split across them. So for example, maybe key phase one has x, key two has y, and we basically want to do the atomic operation across those two keys. And the easy way, or the classic example in the context of transactions is always doing a transfer.", "metadataJson": "{\"start\":146,\"end\":182}"}, {"text": "So let's say the client wants to do a transfer from x to y. Here's our client, and it's going to do basically a put to x to maybe add or subtract from the account. So let's do x minus one. And then the client is going to do a put of y plus one, transferring basically $1 from the account x to the account. Yeah, and our goal is basically going to be, you know, we want automaticity with respect to failures and concurrency.", "metadataJson": "{\"start\":183,\"end\":230}"}, {"text": "So even if, you know, the first kv value server fails after the put, then we would like to arrange it that basically the transfer didn't happen at all. So generally the semantics that we're looking for is that both operations happen or neither one of them happens. And so similarly from a concurrency perspective, if another client is running and also tries to inspect these accounts, then what we would like to be the case is that both puts show up atomically and so another transaction cannot observe an intermediate result where an intermediate result is, for example the money is deducted from x but hasn't been added to y yet. So these are the type of things we want to do. And it's comprised common in distributed systems that you would like to do operation in cross charge.", "metadataJson": "{\"start\":235,\"end\":285}"}, {"text": "So that's sort of the context of what we'd like to do. And the general plan for doing this is, comes actually from the database community. And this general plan is transactions.", "metadataJson": "{\"start\":288,\"end\":300}"}, {"text": "And what we like to do is basically group these operations, for example in the case of the transfer to put operations into a single transaction. And we like then the property that this transaction executes atomically. So typically this requires some programmer annotations. So begin transaction to indicate that the client wants to do start of a transaction. Then maybe then, you know the operations like at x, I guess I did x minus one and then at y plus one.", "metadataJson": "{\"start\":309,\"end\":345}"}, {"text": "And then you have to indicate like when the transaction actually is completed. And so typically we come make it a commit. And so the semantics that we're looking for is that these operations are executed atomically with respect to concurrency and with respect to failure. And just to make it a little bit more exciting, let's look at a second transaction so that we can look at some case studies about how transactions actually interact. We might have a second transaction begin x, which reads actually these accounts.", "metadataJson": "{\"start\":346,\"end\":383}"}, {"text": "So t one gets x and then t two gets y and then print t one, t two and then end or commit.", "metadataJson": "{\"start\":384,\"end\":402}"}, {"text": "So we have a second transaction that basically reads the accounts x and y and then prints the values. And one reason that we have two transactions is so that we can look from the concurrency perspective how these transactions actually ordered and what are legal outcome and what are illegal outcomes. Now, transactions turned out to be a general, almost like a piece of magic. Basically programmers can annotate these begin and end operations and it takes a whole group of operations together, make them atomic and use the system will take care of everything, it will take care of the locking, it will take care of the recovery. It's all like the program doesn't have to worry about it.", "metadataJson": "{\"start\":407,\"end\":446}"}, {"text": "The transactions are a very, very powerful construct, and they're useful in non distributed systems. If you have a single database machine or multicore database machine, and clients are submitting transactions to it, then the transaction systems will execute these as much as concurrently as possible. But also, even if the machine fails and comes back up, you can actually expect the results to be there. Our focus, of course, is going to be on distributed transactions of the ones that I had on the previous slide, namely one, for example, across sharks, which is a common case in data centers. The typical API of a transaction also has one more operation that I didn't list here, and that is abort.", "metadataJson": "{\"start\":446,\"end\":501}"}, {"text": "So the two transactions are shown here are both committing, but you could easily have a transaction that decides to abort. For example, you might discover that, for example, transaction t, one might check that x has sufficient money in it in the account, and if the account doesn't have sufficient money, instead of calling commit, it would call abort, and at that point the transaction would be canceled. And even if a transaction abort sort of halfway through and maybe has done some put operations, the still, the semantics should be that none of those put operations actually happened. So in all cases, whether it's a border commit, either all of them happen or none of them happen. Never a partial result.", "metadataJson": "{\"start\":503,\"end\":549}"}, {"text": "Abort also might be called by the transaction system itself. For example, as we'll see later, if there's a deadlock between two transactions, then the transaction system actually can abort one of the transactions so that the other transaction can continue, and maybe a retry later the transaction that was aborted. Okay, so this is sort of the primitives. You begin transaction, commit, and abort. Those are three key interface operations.", "metadataJson": "{\"start\":550,\"end\":581}"}, {"text": "And then the semantics of transactions are typically summarized by a single word, namely asset.", "metadataJson": "{\"start\":581,\"end\":590}"}, {"text": "And that stands for like four key properties of transactions. One, it's atomic.", "metadataJson": "{\"start\":593,\"end\":601}"}, {"text": "And here really atomic refers to the case where we have two transactions running. And if one transaction does multiple put operations or multiple add operations, all those results will be all visible to the other transaction, or none of them will be visible. So that's one aspect. Sorry, I said this is wrong. Atomic actually means to the crash recovery case.", "metadataJson": "{\"start\":604,\"end\":630}"}, {"text": "So if a transaction actually executes multiple put operations, the transaction crashes halfway. The rule is that all the writes are visible, all rights are on stable storage or non atomic. There's the atomics with respect to crash recovery. The c stands for consistent, which is something we're emotionally not going to talk about. It's more related to databases.", "metadataJson": "{\"start\":631,\"end\":657}"}, {"text": "It's often the case that database have internal invariants like referential integrity is one of them, and the transaction is supposed to maintain that consistency. So no internal consistencies. This is going to be less of a topic for us today. And three is isolated. The I stands for isolated.", "metadataJson": "{\"start\":658,\"end\":679}"}, {"text": "And isolated was the what I just said earlier incorrectly. Isolated actually refers to the case we are running two transactions and they shouldn't observe intermediate results from each other. So again, all the rights are applied, all or nothing with respect to the visibility in other transaction. And then finally the d stands for durable, meaning that if the transaction commits, then the results are written to a stable storage, so that if the system crashes, comes back up later, the latest writes or the latest transactions, the latest committed transactions are actually recorded on stable storage.", "metadataJson": "{\"start\":683,\"end\":725}"}, {"text": "Any questions about sort of a quick introduction to transactions?", "metadataJson": "{\"start\":728,\"end\":732}"}, {"text": "Okay, so I'm going to talk basically about two topics quite a bit, namely the a part of the transactions and the I part of transactions. I'm going to start with the I part and talk a little bit about what actually correct isolation means.", "metadataJson": "{\"start\":742,\"end\":760}"}, {"text": "So basically what we're looking for is a definition for correct execution of multiple transactions. Recurrent transactions in the typical definition or the gold standard in the database literature is called serializable for serializability.", "metadataJson": "{\"start\":764,\"end\":786}"}, {"text": "And what that means is that if you have two transactions or many transactions and they execute concurrently, then the outcome has to be some serial order. So either t one executes before t two or t two executes before t one. But there's some serial order and the serial order has to produce the same outcome as the concurrent execution. So if you run two transactions concurrently, they produce some outcome. That outcome is only valid or legal or correct if it could have been the result of a serial execution.", "metadataJson": "{\"start\":788,\"end\":836}"}, {"text": "Just to make a concrete with our example, let's say in the account case, x starts out as being ten, y starts out as being ten. We run these two transactions that we had earlier on the board. Just quickly remind you what the two transactions are. One basically moves one between two accounts and the other one prints the result of the two. So if we think a little bit about it, if t one goes first, then the outcome is going to be 910.", "metadataJson": "{\"start\":838,\"end\":868}"}, {"text": "And the print statement is going to be the print statement. Actually. Did I say 910? Sorry. 911.", "metadataJson": "{\"start\":869,\"end\":885}"}, {"text": "That's why I got confused. And the print statement is also going to say x was the one that we subtracted. So 911. So we got a string 911 out, and the two values of the counts are nine and nine and eleven. If t two goes first, then the outcome is 1010 because no money has moved yet.", "metadataJson": "{\"start\":885,\"end\":908}"}, {"text": "And then t one goes. And so that's the possible outcome. So that was the two legal outcomes of the two transactions that we're actually, if we execute the two transactions concurrently and the system guarantees serializability. Now you notice that serializability has probably a lot of flavor of the terminology that we used before, namely linearizability. The key difference between serializability and linearizability is that in linearizability there's a real time component that if a transaction t two starts after a t one ends, then t two has to show up later in the total order in the serial order.", "metadataJson": "{\"start\":908,\"end\":954}"}, {"text": "In serializability that is not required. So even if a transaction started wall clock time, a little bit later than another transaction stopped or finished, the system is still allowed to reorder that. So serializability in some ways is a little bit weaker than linearizability. Nevertheless, serializability is a very convenient programming area because from a programming perspective, you can always think about transactions executed in some serial order and you don't have to consider all kinds of interleavings.", "metadataJson": "{\"start\":954,\"end\":989}"}, {"text": "Okay? So even though serializability is slightly weaker than linearizability, it actually, this allows a whole bunch of problematic cases. So let me talk a little bit about that, just to make clear what actually serializability means and what sort of executions the transactions the transaction system actually has to forbid. So let's, you know, two cases like here we have, uh, the first transaction, we have the second transaction running. So t one runs t two.", "metadataJson": "{\"start\":991,\"end\":1033}"}, {"text": "And you know, one outcome that we could have is like one possible execution that might happen is if we don't do something special. You know, t one gets x.", "metadataJson": "{\"start\":1034,\"end\":1046}"}, {"text": "You know, here the transfer happens, so the updates to x and y happen, and then t two does the get a y? And is this a legal, or is this a serial, is this a serializable execution? That's the sort of question we have to ask. And what is the answer to that one?", "metadataJson": "{\"start\":1049,\"end\":1071}"}, {"text": "This is not serializable. Yeah, and because, you know, the outcome, you know, if we write down what the outcome is correct, then the outcome is going to be 911 here. And this is going to write down 1011, right? I think so. And if we go back, you know, to our previous slides, that is not one of the two legal outcomes, right?", "metadataJson": "{\"start\":1074,\"end\":1097}"}, {"text": "So this is not good. So when we think about the implementation of a transaction system, you know, it has to be the case that it forbids this particular execution schedule. And, you know, there's a similar version. Our transactions from these two examples are not so complicated, so there are not that many in the leavings. You have to, you can consider, and that could go wrong, but there's at least one other one that can result in not an incorrect outcome, which is we do the put x first.", "metadataJson": "{\"start\":1098,\"end\":1128}"}, {"text": "So here we go. Then we actually print the two to two gets, so get x, get y, and we do the put of y. And is this a serializable execution?", "metadataJson": "{\"start\":1130,\"end\":1150}"}, {"text": "Is this an execution that we should be forbidden by the serializable transaction system, or is it an okay execution? It should be forbidden. Yeah, it should be forbidden, Greg, because it has an outcome that could not have happened if we executed t one first followed by t two or t two first followed by t one. Right. Okay.", "metadataJson": "{\"start\":1162,\"end\":1184}"}, {"text": "So what we clearly see is that serializability excludes executions in order to actually make it easier for programmers to think about actually what a database does. And there are two broad approaches to forbidding executions. And these approaches, the approach to forbidding is called concurrency control.", "metadataJson": "{\"start\":1184,\"end\":1212}"}, {"text": "In the first approach, or the first category of solutions, is what is called pessimistic solutions.", "metadataJson": "{\"start\":1223,\"end\":1229}"}, {"text": "And the pessimistic solutions basically evolve locks.", "metadataJson": "{\"start\":1235,\"end\":1238}"}, {"text": "So the idea is that like when the transaction runs or starts, it requires the necessary locks to maintain serializability and only release the locks. So when it's guaranteed that the executions will result in a serializable execution. So that's the one approach, and we're going to talk a little bit more about it in a second. The second approach is, is optimistic.", "metadataJson": "{\"start\":1240,\"end\":1267}"}, {"text": "And in the optimistic approach, you know, there's basically no locks and optimistic approach, you just assume things are going to work out. And basically when you get to the commit point, you know, the dissection system sort of asks itself the question, well, you know, all the, given the operation I've done in the past, is that actually, could that be the result of a linearizable execution, or could that be the result of a serializable execution? And if so, things are fine, no problem at all, then, you know, we're good. If it is, the result doesn't correspond to a serial execution, then we're basically just a Borg and maybe, and then we'll retry probably. So we'll see.", "metadataJson": "{\"start\":1271,\"end\":1327}"}, {"text": "I'm not going to talk much about optimistic concurrent control right now, but next week or two weeks from now, actually, we're reading the farm paper and we'll see an optimistic transaction system, distributed transaction system of the type that we're considering that users an optimistic concurrency, concurrency control approach. But the focus for today is going to be on pessimistic. And one, the flip way that these two approaches are described in the literature often is that sort of pessimistic is you ask for permission first and then you do your operations and the optimistic the other way around, you just go ahead and you do your operations. If it turns out to be wrong, you just apologize later.", "metadataJson": "{\"start\":1328,\"end\":1375}"}, {"text": "So that was the analogy, if you will, between the two different approaches. And now within each approach, whether it's pessimistic or optimistic, there are many different concurrency control plans to either increase concurrency or provide weaker consistency with more concurrency. And so there's like a, there's a huge, huge literature, and I'm just going to talk about one particular approach which is very popular, particularly if you want to achieve serializability. It turns out that although I said like serializability is a gold standard for databases, it's often the case that databases offer multiple degrees of isolation. So as a programmer you can sort of pick, you know, the degree of isolation that you'd like and the reason that you may want to pick a weaker degree of isolation so that you can get more concurrency.", "metadataJson": "{\"start\":1377,\"end\":1433}"}, {"text": "Now we're going to just stick to the gold standard of concurrency, which is nameless serializability. And if you do serializability, then a common approach is two phase locking and interface. Locking basically is sort of a walk per record. That's the starting point for database record. And in our little example that would be sort of a lock per variable, a lock per for x and a lock for y.", "metadataJson": "{\"start\":1434,\"end\":1473}"}, {"text": "And there's basically two rules. One, transaction acquires a lock before using.", "metadataJson": "{\"start\":1474,\"end\":1487}"}, {"text": "And so the idea is before, you know, you can read or write, you know, to x or y, you first have to obtain the lock and the transaction system will do this for you. And two, the t holds a lock. Once you acquire it, you're not allowed to release it until commit or abort, whatever, whatever is the end of the transaction. And so in our particular case, if we have like t one running and we have t two running and t one walks x first and then, you know, lock y and it has to maintain those locks until it actually reaches commit points.", "metadataJson": "{\"start\":1492,\"end\":1538}"}, {"text": "So if t two runs at the same time, or roughly at the same time, if two t t two starts a little bit later and tries to grab the lock in x, t one will have it. If t two started a little bit later and at that point, you know, basically t two has to wait a sort of standard locking protocol. And the basic idea of two phase locking is that it's sort of a refinement or an improvement over this simple locking scheme that is described in the document, which sometimes is called simple locking or strict locking, where basically at the beginning of the transaction you grab all the locks you need for the whole transaction, you hold them until the end, and then you release them. And two phase locking is a little bit more fine grained in that even if the transactions might, they don't require the locks immediately all at the same time at the beginning, and instead they require the locks incrementally as the transaction runs, which allows certain concurrency patterns that are disallowed by strict locking.", "metadataJson": "{\"start\":1540,\"end\":1606}"}, {"text": "The first rule seems pretty clear, you know, why you need it. The second rule might be maybe less obvious, and so it's probably a good idea to actually sort of see what goes wrong if you did not maintain the second rule. And so let's say, talk a little bit about intel commit.", "metadataJson": "{\"start\":1608,\"end\":1626}"}, {"text": "And so here we have our two transactions, t one and two, the transfer and the print statement. And so let's say, you know, here we do our put of x. And so that means before the put of x, the transaction system locks x. And let's say that we're not following the two phase locking rule and we actually release the lock x right after the put because we're done with it actually doesn't show up in transaction t one anymore. You know, there will be a later put.", "metadataJson": "{\"start\":1632,\"end\":1664}"}, {"text": "But that's the put to. Yeah, and let's assume that before actually we get to the locking of Y, t two runs and actually t two, basically the whole, the two gets the get of X and the get Y run. And so since t one released the lock on X, it can get the lock on X. Since t one hasn't gotten to the boot yet, you know, it can also get the lock on Y. And so, you know, print X and Y and reset and then release the locks.", "metadataJson": "{\"start\":1664,\"end\":1702}"}, {"text": "So is this, would this be a serializable execution?", "metadataJson": "{\"start\":1706,\"end\":1716}"}, {"text": "Now it's the same as before? Yeah, it's exactly the same as before. Correct. Because basically the print statements like here, they sort of slipped in between the two, the put and again, and the y between the two puts of the x and the y. And we already concluded earlier that is not a serializable conclusion, that's a serializable execution.", "metadataJson": "{\"start\":1721,\"end\":1739}"}, {"text": "So this is wrong. And so this is an example of demonstrating that if you release the lock too early, in this case t one released the x too early, you're not going to get a serializable execution. And one way to think about it, basically, is that whenever there's sort of an intersection between, you know, two lock sets. So t one has a lock set of x and y, t two has a lock set of x and y two is important. You know, during these two transactions, get ordered in a particular way.", "metadataJson": "{\"start\":1739,\"end\":1771}"}, {"text": "That means that if the locks intersect, we have to make sure some total ordering. And that means that we actually have to hold the locks to the end until the commit point so that no intermediate results of the transaction are actually visible to other transactions. We release the locks before the commit point. We might actually make a result visible, even though maybe later aborted and then the whole change will go away. So this is the reason why locks must be held to the end.", "metadataJson": "{\"start\":1771,\"end\":1801}"}, {"text": "Now, an obvious problem that many of you asked about in two phase locking is isn't there a chance of deadlock if you're requiring the locks as the transactions execute? And so let's. And this is absolutely the case. And so, for example, let's modify t two slightly. So t two used to be, you know, t one, you know, gets x.", "metadataJson": "{\"start\":1803,\"end\":1830}"}, {"text": "Instead, we're going to do it in the opposite order. We're first going to get y and t two gets x. And we remain, we keep t one the same. So t one actually still does first to put to x and then the put to y. So now we can easily get into trouble.", "metadataJson": "{\"start\":1830,\"end\":1847}"}, {"text": "So this is t two prime and this is just ordinary tu one that we already have. It does a put of x. Before doing the put of x, it needs to get the lock on x. L locks x. Now let's say that the ordering works out as follows.", "metadataJson": "{\"start\":1848,\"end\":1868}"}, {"text": "At the same time, t two prime runs, it does a get y. So that means it got the lock on. Yeah. And now you can easily see what goes wrong here. Now, t one is going to do a put of y or it wants to do a put of y.", "metadataJson": "{\"start\":1868,\"end\":1886}"}, {"text": "So we need to get the lock on y. But it can't get it because, you know, t two prime actually has to lock. So it has to wait here. That's the block. You know, the same thing is going to happen.", "metadataJson": "{\"start\":1886,\"end\":1899}"}, {"text": "Of course, on the other side, you know, before doing the get off x, t two needs to get the lock off x. And it can't get the lock of x because t one has it. And so this has to wait two. And now we have t one waiting on t two prime and we have tt prime waiting on t one. We basically have a deadlock.", "metadataJson": "{\"start\":1899,\"end\":1925}"}, {"text": "Now what is the cool part about transaction systems is that we have this abort operation. And so if the transaction system could detect a deadlock, could you abort one of the two transactions, let the other one proceed, and hopefully that will actually get to the end and commit and abort the other one. And then the client or the application can decide what to do with the aborted transaction. It can actually retry it, maybe wait a little bit and then retry it in the hope that at that point you're not going to run into a deadlock. And so one way to think a little bit about two phase locking is that it has a little bit of a, sort of an optimistic flavor to it in the sense that it's not guaranteed that it won't run into problems.", "metadataJson": "{\"start\":1928,\"end\":1973}"}, {"text": "But even if it runs into problems, you can always abort and then recover from that problem.", "metadataJson": "{\"start\":1973,\"end\":1979}"}, {"text": "Any questions about this?", "metadataJson": "{\"start\":1982,\"end\":1984}"}, {"text": "Sorry. So how do you, how do you find the deadlock? That's exactly. I was hoping that somebody was asking that question. So the way there's sort of two broad approaches that people use.", "metadataJson": "{\"start\":1990,\"end\":2001}"}, {"text": "One is one is not as solid as you will. One issue is basically on a timeout basis. Like if the transactions are running for a long time and, you know, then they don't seem to make forward progress, you can just abort one of them. And so this is timeout based. The more systematic sort of way of thinking about it is to construct a wait for graph as the transaction systems, you know, are moving.", "metadataJson": "{\"start\":2002,\"end\":2030}"}, {"text": "So, for example, if t one runs. So in the wait for graph, the transactions are the nodes. So we got the node t one, and we make a node t two when they start, or t two prime, if you will. And when t one runs, you know, it gets x, nothing to do. Then it gets to the lock of y.", "metadataJson": "{\"start\":2030,\"end\":2048}"}, {"text": "It can't do it. So we'll make an arrow from t one to t two prime to indicate that t one is waiting for t two prime. Then at some point, like t two is running t two hits this two t prime hits this point where it wants to lock x. It can't do it. So we'll look at, like, where it's waiting for who's holding the lock.", "metadataJson": "{\"start\":2048,\"end\":2070}"}, {"text": "Well, it's t one. And so we'll put an edge, you know, in the wait for graph from t two to t, from t two prime to t one. And now we see there's a cycle. And whenever there's a cycle, that means that there's a deadlock, right? Because one is waiting on the other, and the other is waiting on the other first.", "metadataJson": "{\"start\":2070,\"end\":2088}"}, {"text": "And so the transaction system can sort of construct these graphs on the fly, detect when there is a cycle in the graph, and then for example, either abort t one or abort t two prime. So this is called the weight for graph.", "metadataJson": "{\"start\":2088,\"end\":2107}"}, {"text": "What happens after the abort?", "metadataJson": "{\"start\":2113,\"end\":2114}"}, {"text": "Well, so let's say we abort t two just for, as an experiment. So we're going to kill this guy. So t two, basically this transaction system is going to arrange, as we'll see in a second, it's going to arrange that basically none results of t two. Are t two prime invisible. At that point the lock is released.", "metadataJson": "{\"start\":2117,\"end\":2139}"}, {"text": "The board will force the lock release of the y because t two prime is backing out. That means that t one can get the lock on y and proceed to finish. The client that called t two prime is going to learn that the transaction aborted and for example it can just choose to rerun it again.", "metadataJson": "{\"start\":2139,\"end\":2158}"}, {"text": "Does that all make sense?", "metadataJson": "{\"start\":2164,\"end\":2165}"}, {"text": "So this is sort of the first part actually all of what I wanted to say about two phase locking, except I wanted to address the sort of homework assignment again, which is like, in what situations does two phase locking allow for more concurrency than strict locking, where strict locking was the protocol where a transaction acquires all the locks in advance. And this requires that the programmer, or like the beginning of the transaction, basically declares which locks that transaction actually needs. So they're slightly undesirable, like less programmer friendly. But it has the advantage that you don't actually, you can't run into these, you don't have to abort a transaction at the end in the case you run into a deadlock. So two phase locking allows for more concurrency in principle, or it should allow for more concurrency than the strict locking or the simple locking scheme.", "metadataJson": "{\"start\":2171,\"end\":2227}"}, {"text": "So I would like to do is a quick breakout room for a couple of minutes, like five minutes again, and convince yourself, or construct a case where simple locking would disallow some concurrency that two phase locking was actually able to exploit. Cool. All right, let's do breakout runs.", "metadataJson": "{\"start\":2227,\"end\":2250}"}, {"text": "Okay, see you in five minutes.", "metadataJson": "{\"start\":2254,\"end\":2256}"}, {"text": "We can't hear you.", "metadataJson": "{\"start\":2647,\"end\":2648}"}, {"text": "I think you're muted.", "metadataJson": "{\"start\":2657,\"end\":2659}"}, {"text": "I have a question about one of the previous slides that you're talking about. Hold on a second, let me double check if everybody can hear me now. Yes. Okay, good. Go ahead on one of your previous.", "metadataJson": "{\"start\":2676,\"end\":2691}"}, {"text": "Or I guess this is just a general question, but is the lock point always the same as the commit point? Or is it possible to start relinquishing locks before your commit point? Okay, this is a very good question. So depends. So if you only do exclusive locking, as we've done so far, at least in my examples, then the commit point is similar to the lock point is similar to the commit point and the board point.", "metadataJson": "{\"start\":2691,\"end\":2718}"}, {"text": "If you have read write locking. So locks that allow you have both read locks and write locks, then it's possible to release read locks earlier with some restrictions.", "metadataJson": "{\"start\":2718,\"end\":2730}"}, {"text": "Thank you. Okay, so can somebody give me one example of where two phase locking allows for more concurrency than simple locking? Just to make sure that we all on the same page?", "metadataJson": "{\"start\":2732,\"end\":2747}"}, {"text": "The audit function example, like you can release the lock as soon as you read this person's amount. Like you don't have to wait until you read everyone's. This is an example of exploding the read logs. If you have read logs.", "metadataJson": "{\"start\":2752,\"end\":2768}"}, {"text": "Any other examples?", "metadataJson": "{\"start\":2775,\"end\":2776}"}, {"text": "If you have a transaction where there's like a condition that only rarely like is true, and you read a piece of data when it's true, so at the beginning you don't need to acquire the lock for that, only when you actually need to read it. Yep, that's a great example. I personally like that example a lot. That's a great one. Good.", "metadataJson": "{\"start\":2779,\"end\":2799}"}, {"text": "Okay, good. So let's move on basically then to the second topic of this lecture, which is two phase commit, and this is really dealing with crashes.", "metadataJson": "{\"start\":2799,\"end\":2811}"}, {"text": "Switch back to blue. I don't know why we can't see the slides either, yet. Oh, let me fix that.", "metadataJson": "{\"start\":2813,\"end\":2828}"}, {"text": "Hold on.", "metadataJson": "{\"start\":2831,\"end\":2832}"}, {"text": "Share screen stuff to share. How about now? All good. Thank you. All right, so two phase commitment, or two pc, as it's popular, called.", "metadataJson": "{\"start\":2835,\"end\":2856}"}, {"text": "Again, this is a very well known popular protocol. I'm going to talk about the base, sort of simple, straightforward, or the most common version of the protocol. There are all kinds of variations of it, but they all have the same underlying idea. And so again, typically in two phase protocol, and I'm going to do it in the context of the transfer transaction. So a client that actually wants to do a transfer basically submits the transfer transaction to the transaction system.", "metadataJson": "{\"start\":2856,\"end\":2895}"}, {"text": "And the machine that sort of receives that transaction is called the coordinator, and that machine is in charge of running the transaction through the transaction system. And so the coordinator will talk in our case to two different machines, a and b, where a holds x and b holds y. And, and basically one way that this typically goes is that the coordinator first sort of does the whole transaction, but in a tentative way. So the put x results in a message to a locking a modifying a put x, except the put is not actually visible yet in the database. What is done, it is put in a log, very much like in sort of in the Francipani style where we have a write ahead log.", "metadataJson": "{\"start\":2896,\"end\":2960}"}, {"text": "All the operations that we at some point want to materialize in the database itself. We first put in the log until later, in this particular case, until we hit commit and then we actually will install everything in the database. So we'll do the put, we do a second put Y and the same thing happens there. We get a lock on Y. Okay, so this should have been lock on X and we'll do a put on Y.", "metadataJson": "{\"start\":2960,\"end\":2989}"}, {"text": "And again, we're going to not actually really put the value in the database. We're just going to log fix. So we're log and here we log x.", "metadataJson": "{\"start\":2990,\"end\":3000}"}, {"text": "And now the coordinator has done two of the transactions, the two of the main operations, and now sort of ready to commit. And here's where the two phase part comes in. And so the coordinator will send a prepare message. And I'm first going to describe this protocol in the case there's no failures and everything works out. Just start sort of the easy case, as you will, sends a prepare message.", "metadataJson": "{\"start\":3003,\"end\":3033}"}, {"text": "It sent a prepare message to, to prepare a, prepare b.", "metadataJson": "{\"start\":3033,\"end\":3041}"}, {"text": "And the prepare message, of course, includes the transaction id that is actually used for this transaction. So every transaction has a transaction id and all the messages are tagged with the transaction id. So we always know about which transaction we're talking about. When a and B receive these prepared messages, they look at their state, see if they indeed can actually execute the transaction. They're holding the lock on X.", "metadataJson": "{\"start\":3045,\"end\":3073}"}, {"text": "In this case, the x is actually in the log. And so they sent back saying, yep, I'm ready to commit. Yes, yes. And at this particular point, here's where the crucial sort of step is the coordinator now knows that basically both a and b are prepared to commit. And so I have basically promised to commit by actually responding.", "metadataJson": "{\"start\":3073,\"end\":3104}"}, {"text": "And at this point, the coordinator commits and then sends messages again to the a saying commit the transaction tid, similar message to b. You know, commit tid.", "metadataJson": "{\"start\":3104,\"end\":3124}"}, {"text": "And at this particular point, a and b actually perform the operation. So they basically install. At this point, you know, they install, you know, the log version of Y. Here this transaction, this participants installs the x and they release the locks. So release of y and here the release of x.", "metadataJson": "{\"start\":3127,\"end\":3152}"}, {"text": "And they respond back, you know, to the coordinator saying like, yep, all done. And at that point, you know, the direction is completely done. And in fact, you know, the coordinator doesn't really have to remember anything anymore about this particular transaction. And also see later, a and b need to remember their state a little bit longer until they hear about the next transaction. So this is the core basic case when there's absolutely no failures and we see what we actually get the desired outcome correct.", "metadataJson": "{\"start\":3152,\"end\":3188}"}, {"text": "When does the coordinator commit? The coordinator commits only if a and b agree.", "metadataJson": "{\"start\":3188,\"end\":3203}"}, {"text": "Okay. It could be the case that, for example, when the coordinator sends a message to b, that b decides, well, I can't really commit, maybe so there could be multiple reasons for it. Maybe the b actually is in a situation where there's a deadlock with y, or there's no space in the log anymore, or there's not enough money in the account of y. And so b could respond with a no, let's say in this. So the other possible outcome is the prepared message can send a man the no back, and in that case, the coordinator gets one yes from a, no from b.", "metadataJson": "{\"start\":3208,\"end\":3253}"}, {"text": "So both do not agree. And in that case, the coordinator cannot commit the transaction and then would actually abort the transaction and then, say, the board messages to a and b, basically discontinuing the transaction. So those are the two possible outcomes. One in the commit case, one in the board case, and where it is always the case that transaction only commit, the top level transaction only commits if both of the participants that are involved in the transaction agree to do so.", "metadataJson": "{\"start\":3253,\"end\":3281}"}, {"text": "Now that's sort of the outline of the protocol. So I want to now go through a couple of cases to understand what can go wrong and how we deal, how two phase commit arranges. That actually still the right thing happens. Actually, I have a question here. So we said that B might decide that it needs to abort and sends back a no message.", "metadataJson": "{\"start\":3285,\"end\":3309}"}, {"text": "What if it decides it needs to abort after it replied yes? Would that ever be possible? No. We'll talk about it in a second. But that's absolutely not possible.", "metadataJson": "{\"start\":3309,\"end\":3319}"}, {"text": "If you promise to commit, you have to commit or you have to be ready to commit. No, you have to be ready to commit. You don't commit right away. You have to wait until the commit message, of course, but you cannot bail out anymore. So until the prepare, the B can unilaterally abort a transaction.", "metadataJson": "{\"start\":3320,\"end\":3338}"}, {"text": "Once a promise. Yes, it cannot unilaterally abort a transaction anymore. So is it possible where you're in deadlock, but you can't get out of the deadlock because everyone in that cycle has agreed to prepare a commit. If everybody agrees to prepare and they can definitely commit, then they will commit, and you're still holding blocks. Right.", "metadataJson": "{\"start\":3339,\"end\":3362}"}, {"text": "But what if you're in deadlock because we mentioned before how one of the reasons why you might want to order, you would find it out before the prepare, if you get the locks, and why, if you did not succeed in getting the necessary locks for the transaction, then you know, at that point. Right. Thank you. Okay, so this is exactly the kind of discussion that's going to come up. So I'm going to go, I'm going to take the same board and replicate it and consider a bunch of different cases.", "metadataJson": "{\"start\":3362,\"end\":3393}"}, {"text": "So here's the same board again, nothing has changed so far. It's identical. And so what's the first to sort of follow up on this question that we just asked, let's first consider the case where B is in the prepared state and then crashes, like right after. So it is prepared, it pointed back, sent back to the coordinator that it actually is agreeing to go along. And right after it sends actually the prepare message.", "metadataJson": "{\"start\":3393,\"end\":3435}"}, {"text": "Okay, message, it actually crashes. What does that mean?", "metadataJson": "{\"start\":3435,\"end\":3440}"}, {"text": "What needs to happen? How we're going to resolve this or what is the risk? So basically b crashes. If b crashes, we need to abort the whole thing, right? No, we cannot abort anymore.", "metadataJson": "{\"start\":3442,\"end\":3456}"}, {"text": "Right. Because, you know, b already promised that it's going to commit. We're going to use the log. Yeah. Well, okay, so b is going to crash and then at some point it's going to come back up.", "metadataJson": "{\"start\":3456,\"end\":3468}"}, {"text": "Right. It's going to recover, hopefully. And what state does it need to remember across crashes?", "metadataJson": "{\"start\":3468,\"end\":3475}"}, {"text": "It needs to remember that it prepared. Yeah, I need to remember, correct, that it prepared for transaction id, whatever the tid was, and that is holding the lock on why. And so when it comes back up, the first thing it has to do is sort of look, saying, like, how was I in the middle of a participant in a distributed transaction and I should look at the state and you'll see that it was actually prepared for transaction id tid. And it must hold the lock for lly or the lock for y before does anything else, you know, before talking to anything. Once it is in that state, then it is if it didn't crash and things are sort of back to normal.", "metadataJson": "{\"start\":3479,\"end\":3524}"}, {"text": "And hopefully at some point the coordinator will retry the commit message, the B will get that commit message for this transaction id sees that, yeah, I'm indeed prepared and I hold the lock and y and so it just goes along and installs y and etcetera, finishes the transaction.", "metadataJson": "{\"start\":3524,\"end\":3541}"}, {"text": "Does that make sense? So basically there's a little bit of a refinement here that we actually have to write some stable some data to stable storage as part of the transaction, as part of two phase commit. This is one of the reasons that two phase commit is a little bit expensive, because not only we have to send multiple random messages, but also a participant actually has to write things to stable storage. And as we talked about before, writing to stable storage is quite expensive. It could be easily a couple milliseconds.", "metadataJson": "{\"start\":3543,\"end\":3577}"}, {"text": "Let's say it's one millisecond. Optimistically, that means basically that we're immediately limited to 1000 transactions per second, no more.", "metadataJson": "{\"start\":3577,\"end\":3585}"}, {"text": "Let's consider another case. And so let me duplicate this slide again. Um, and, uh, consider yet another case. Um, let's say, uh, we, uh, the coordinated crashes. And so, uh, you know, here's red again.", "metadataJson": "{\"start\":3588,\"end\":3616}"}, {"text": "And, you know, we got like one, we got the prepared messages, and the coordinator maybe even set out one commit message and then crashes, like right here. You know, what, what do we need to arrange, you know, to make sure that the whole plan works out?", "metadataJson": "{\"start\":3618,\"end\":3636}"}, {"text": "So the coordinator needs to store into persistent state what, what are the commands that were promised to be committed but were not committed? Yeah. So the converter is almost the same as sort of the, it's an analogous to B's case. Correct. Now, if we commit a transaction, we need to write to stable storage that we're actually committing the transaction.", "metadataJson": "{\"start\":3642,\"end\":3660}"}, {"text": "So we need to write to stable storage, you know, commit tid so that then when the coordinator comes back up, then it can actually finish the transaction until actually the a and b that indeed the transaction is committed. Because a and b are waiting. Right? A and B said like, yeah, we're happy to go along. And they're just waiting and waiting until actually they hear from the coordinator to decide what's done.", "metadataJson": "{\"start\":3660,\"end\":3685}"}, {"text": "Because once they decided, once they went along, or once they agreed to go along, they cannot unilaterally anymore bail out. Because let's say they actually both said that they agreed along, then it means that the coordinator, they don't know. The coordinator may have sent a commit message to, for example, a, and a actually has committed the transaction. You know, b hasn't heard yet. Maybe the message got delayed, then the coordinator crashed.", "metadataJson": "{\"start\":3685,\"end\":3712}"}, {"text": "And, you know, at that point, it would be totally wrong for b to abort. The transaction really has to wait until the coordinator comes back to tell what actually the outcome is of the transaction.", "metadataJson": "{\"start\":3713,\"end\":3724}"}, {"text": "Okay, so let's see. Sorry. The only message that the coordinator is not going to resend is prepare that one. If it gets like, doesn't get a yes, it'll just abort. Yeah, actually it was the next example.", "metadataJson": "{\"start\":3727,\"end\":3746}"}, {"text": "So let's do that. Let me duplicate this board again and talk about that case. So just for fun, let's move it down so we don't lose track. So let's say, you know, the following thing happens. This prepare message never makes it.", "metadataJson": "{\"start\":3746,\"end\":3766}"}, {"text": "Right. And then, you know, the coordinator can unilaterally decide to abort. Right. And in effect you can tell b, you know, to abort. And you know, a doesn't really need to know anything about it.", "metadataJson": "{\"start\":3767,\"end\":3783}"}, {"text": "At some point later, you know, we'll come up and can ask the coordinator. If the coordinator doesn't know anything anymore about this transaction, you can just tell I aborted because I don't have a commit record anymore and I was not waiting to inform anybody. So in that case we can do an abort. And that means that b can release the logs. Correct.", "metadataJson": "{\"start\":3787,\"end\":3807}"}, {"text": "And b can just proceed, you know, happily trying to do other transactions that might involve. Why.", "metadataJson": "{\"start\":3807,\"end\":3815}"}, {"text": "Okay, sorry. So what will happen if the message two, a gets lost, the coordinator aborts and then b crashes, but then when it comes up, is going to wait for a commit message from the coordinator, but the transaction has aborted already. Yeah. Or so either there's two cases, you know, presumably, you know, in the most protocols, actually b will ping the coordinator because it knows who's the coordinator and ask if, hey, what's the outcome of that transaction?", "metadataJson": "{\"start\":3818,\"end\":3849}"}, {"text": "Okay, so one more case. I want to return to one case that is actually sort of the, the most interesting case, one of the more tricky cases. So I just have a brief question. Yeah, hold on, hold on 1 second. Sorry.", "metadataJson": "{\"start\":3855,\"end\":3868}"}, {"text": "Yeah, yeah. So the first question is that, so b, let's say, holds the lock on y all the way through between putting y into the log until installing y to its actual state. Okay. And then the second question. So the locks here are distributed because we're dealing with across servers.", "metadataJson": "{\"start\":3868,\"end\":3890}"}, {"text": "Or I mean, if y only exists on the server b, then maybe we don't need distributed locking. So I'm just curious of what the setup. Yeah, the setup is basically the a maintains the locks for all the shards that it has for all the variables or all the records that it has. And b maintains all the logs for all the records it has. Okay.", "metadataJson": "{\"start\":3890,\"end\":3907}"}, {"text": "But if we, for example, have y being on multiple servers, then we need some sort of distributed logging. Yeah, yeah, yeah. So this is, we're talking about the sharded case. Correct. Where the accounts are sharded across multiple servers and only one server has a particular account.", "metadataJson": "{\"start\":3907,\"end\":3920}"}, {"text": "Awesome. Thank you. I'll come back to this later. Actually, one more time. So the first thing I wanted to point out, let's go back to sort of the.", "metadataJson": "{\"start\":3922,\"end\":3931}"}, {"text": "The case where b or a, you know, said yes and then crashes.", "metadataJson": "{\"start\":3933,\"end\":3943}"}, {"text": "Correct. Or actually, let me see, is this the case? No, I want the case, the following case. Sorry, fix this line. So a and b promised their thing.", "metadataJson": "{\"start\":3945,\"end\":3958}"}, {"text": "But I want to go back to the case where that we already discussed, which is right after the commit point, the coordinator crashes.", "metadataJson": "{\"start\":3959,\"end\":3969}"}, {"text": "And we know this interval of time from here to there. Basically, b cannot unilaterally abort anymore because it promised to go along. And it might be the case that actually a did, actually already did the commit, and so it cannot unilaterally abort anymore. And so there's only one option in this case. And what is that one option?", "metadataJson": "{\"start\":3971,\"end\":3999}"}, {"text": "We just wait. Yeah, that's unfortunate, but true. The only thing that b can do is wait. And it's still holding the lock on Y. Correct.", "metadataJson": "{\"start\":4012,\"end\":4024}"}, {"text": "So that means that any other transaction that involves y cannot proceed. One has to wait until the coordinator comes back and announces or re announces whatever the decision was that actually was the outcome for that particular transaction. And this is one of the sort of, you know, sort of the two aspects. This is one of the sort of aspects of two phase commit that are a bit undesirable. Right.", "metadataJson": "{\"start\":4024,\"end\":4051}"}, {"text": "Where the. The protocol might just block until a machine comes back.", "metadataJson": "{\"start\":4051,\"end\":4058}"}, {"text": "Does that make sense?", "metadataJson": "{\"start\":4060,\"end\":4061}"}, {"text": "So how do people do deal with this in practice? Well, it's a little bit unfortunate, but here's where some of our techniques from the past can come to rescue. What could we do with the coordinator to make this scenario unlikely?", "metadataJson": "{\"start\":4065,\"end\":4080}"}, {"text": "So we can make it fault tolerant. Yeah, make it fault tolerant. How could we do it?", "metadataJson": "{\"start\":4086,\"end\":4090}"}, {"text": "Well, there are multiple approaches, but. And we can do it maybe through raft. Yeah, run raft to basically run the coordinator, not on a single machine, but basically have a replicated state machine that implements the coordinator. And we use raft to keep the replicated state machine that implements the coordinator in sync. And then if one of the machines that forms the coordinator fails, hopefully the two others are still there and so we can still proceed.", "metadataJson": "{\"start\":4093,\"end\":4127}"}, {"text": "Right. And so it's potentially possible to basically, you know, replicate the coordinator or actually any of the participants too know, using raft. So let me actually put this up a little bit and so talk a little bit more.", "metadataJson": "{\"start\":4127,\"end\":4144}"}, {"text": "A couple of discussion points, which is, you know, we could use raft to make the coordinator full tolerant or available, if you will. That's really the property we care about.", "metadataJson": "{\"start\":4149,\"end\":4166}"}, {"text": "Does that make sense?", "metadataJson": "{\"start\":4171,\"end\":4172}"}, {"text": "In fact, if you will, see, if you do lab four instead of a project, this is exactly actually what Lab four does. Lab Four actually has a similar scheme where there's a form of two phase commit that you implement. And both the master sharder or the master coordinator that rebalances shards across shard servers, uses raft to replicate itself. And actually shard servers itself also replicate itself using raft. And so we're many, many RAC groups running in parallel, and that's the essence of lab Four.", "metadataJson": "{\"start\":4176,\"end\":4214}"}, {"text": "And so this is like typically your way, you know, if you're concerned about like having the system being blocked for a long period of time, you know, one way to do it is basically make the coordinated fault tolerance.", "metadataJson": "{\"start\":4214,\"end\":4226}"}, {"text": "So that maybe brings me to something else which a lot of people asked about, you know, is raft or raft and two phase commits sort of similar things.", "metadataJson": "{\"start\":4231,\"end\":4242}"}, {"text": "Or could you do two phase commit with raft? Or they have a little bit of a parallel. Correct. There's like one thing is called the coordinator. Raft is called the leader.", "metadataJson": "{\"start\":4245,\"end\":4256}"}, {"text": "We got participants, you know, maybe, you know, we can figure out these are followers. So, you know, seems to have some similarities. Like how do we think about it? Like what's the relationship between Raft and two pc?", "metadataJson": "{\"start\":4256,\"end\":4269}"}, {"text": "The difference is that in raft, the coordinator can change. Essentially true. Otherwise it's like the single point of failure. Yep, good point. Any.", "metadataJson": "{\"start\":4272,\"end\":4283}"}, {"text": "So another difference is that raft basically depends on the concept of a majority, whereas in two phase commit, the coordinator needs to get a response from every single other server that is involved in the commit. Yeah, that was a good point. So these are almost like protocol differences. And we're wondering if can we get to a point where is there a conceptual difference? Do they solve the same problem?", "metadataJson": "{\"start\":4285,\"end\":4308}"}, {"text": "Raft is for replicating the same thing and two face to matters. When you do the opposite, when you, instead of having one thing, you spread across different servers, then you have to deal with the problem. Exactly, exactly.", "metadataJson": "{\"start\":4310,\"end\":4323}"}, {"text": "In raft, all servers do the same thing.", "metadataJson": "{\"start\":4325,\"end\":4328}"}, {"text": "They implementing a replicate state machine. Right. And in two pc, actually servers, or all servers operate on different data.", "metadataJson": "{\"start\":4333,\"end\":4343}"}, {"text": "The first participant was actually operating on X and the second participant wasn't operating on Y. So in two pc really solves a completely different problem than Raft. Raft is really all about high availability and two PCs really about atomic operations across servers or across data that's living on different servers. Does that make sense? So even though maybe they have some internal techniques that look very similar, the two protocols are designed for completely different problems and not directly related.", "metadataJson": "{\"start\":4355,\"end\":4404}"}, {"text": "Now, it's interesting to see, correct, that we could make a raft we can use raft to make the coordinate a more fault tolerant. Or the petitions are more highly available, but they basically essentially solve different problems with that. Actually, I wanted to end this lecture. I'm happy to entertain more questions. Hopefully this will be very helpful in the next two papers.", "metadataJson": "{\"start\":4404,\"end\":4433}"}, {"text": "So the next two papers are both two transaction systems, one from Google and one from Microsoft Research. And the second one uses optimistic transactions. And you will see when you read these papers, there's a lot of machinery, they're pretty complex systems, but hopefully at least some of the parts that will be described you will now understand, because you know what two phase commit is and you know what two phase locking is. Okay with that, I'll end. Everybody who needs to go can go, and anybody who wants to ask questions, please feel free to do so.", "metadataJson": "{\"start\":4433,\"end\":4470}"}, {"text": "Sorry, this might be a little, a strange question, but bit for two phase locking, it is also about atomic operations, but there it is about one, not across servers, but across one server and two faces across multiple servers. Yeah, two face walking is irrelevant too. If you have a single machine, like a multicore machine, and you're implementing a transaction system on a multicore machine, you will have to walk the records that are involved in the transaction. And two phase locking is a perfectly good protocol for doing so, where two phase commit is really about distributed systems. I guess my question was, is two face locking, can it be part of two face commit?", "metadataJson": "{\"start\":4476,\"end\":4528}"}, {"text": "I'm not sure I know what that means. The way I think about this, they do solve two different problems.", "metadataJson": "{\"start\":4530,\"end\":4536}"}, {"text": "Okay. It is the case that, you know, if you, maybe this is what you mean. It is the case where that, you know, there's the coordinator or as part of like the initial setup, like when the initial puts are done by the transaction, that transaction will follow two phase locking. Here the lock on a x is required, the lock on b is required. So lock on y is required.", "metadataJson": "{\"start\":4538,\"end\":4564}"}, {"text": "And so the transaction does that in a two phase locking style. It couldn't have done it using strict locking too. But from the two phase commit point of view, it doesn't really matter. Like at some point the transaction is tentatively executed and the two phase commit is really about reaching agreement that all parties agree to go along.", "metadataJson": "{\"start\":4564,\"end\":4586}"}, {"text": "That makes sense. Thank you. You're welcome. Is two phase commit exclusively for like sharded data? No, actually it came out, although yes or no, the original sort of two phase commit came out of the case where like you have different organizations and they need to agree to do something.", "metadataJson": "{\"start\":4588,\"end\":4611}"}, {"text": "Like, you know, your book on some travel website, you book a trip and another thing, you book a hotel and you want to sort of commit to the whole trip. If both the hotel website and the travel website agree to go along or sort of commit to the deduction. And that's sort of the setting where, the setting where it came up is really, you have different organizations that need to commit to a particular operation, and for the reasons that in that setting, actually, basically, people don't really want to use two phase commit because that would mean that the travel agency website is dependent on the hotel reservation website, and these are from different organizations, and the organization don't really trust each other. And if one goes down, then there's a section can't proceed. And so that seems all bad.", "metadataJson": "{\"start\":4611,\"end\":4674}"}, {"text": "So, in fact, two phase commit had a sort of a bit of a negative reputation. This is really, you know, one of the original goals of two phase commit was to solve that problem, but that problem where people don't really want to solve with two phase commit. However, in the context where, like, you have a data center, it's a single organization, and the database is sharded, two phase commit is widely popular and typical use.", "metadataJson": "{\"start\":4674,\"end\":4697}"}, {"text": "Awesome. Thank you. You're welcome. Could you go back to the first failure case that we talked about with two phase commit where it fails, b fails after responding, prepared. Okay, yeah, I think this is this one.", "metadataJson": "{\"start\":4700,\"end\":4716}"}, {"text": "Yeah, I guess I think I talked twice about this case, but like. Yeah, yeah, I guess I was wondering why bead needs to persist or like, why it needs to remember that it received preparer. I guess my thinking was, when it comes back up, if it receives a commit message from the coordinator, couldn't it just assume that it was prepared? I guess. Where does it use that information?", "metadataJson": "{\"start\":4717,\"end\":4746}"}, {"text": "Yeah, well, we could have aborted correct before the crash, and b needs to remember what it did. Okay, so there's another slight variation of this protocol where you assume that you always commit commit, so presumed commit, where the message is slightly different. And, you know, there's an optimization that you could consider and would make sense in some settings. I didn't really talk about that particular protocol, but there's a slight different, you know, sort of variation. There's quite a number of variations for two phase commit change in minor ways.", "metadataJson": "{\"start\":4747,\"end\":4782}"}, {"text": "Make sense. Yep. Thank you.", "metadataJson": "{\"start\":4785,\"end\":4787}"}, {"text": "Is that it for today?", "metadataJson": "{\"start\":4794,\"end\":4795}"}, {"text": "Sorry? You said that it can, it could have aborted the transaction, but if it did that, it will never receive the commit. You mean in response to the last question? Yeah, yeah, yeah. You know, the question was like, why does he have to record on stable storage what it decided to do?", "metadataJson": "{\"start\":4797,\"end\":4817}"}, {"text": "And the answer is that when B comes up, it knows. It needs to know whether it actually agreed to commit or agree to abort. And if it doesn't write anything, it doesn't know to what a degree.", "metadataJson": "{\"start\":4817,\"end\":4831}"}, {"text": "Because it could have aborted after. Yep. Yeah.", "metadataJson": "{\"start\":4834,\"end\":4838}"}, {"text": "I need to know that to know what to do in the recovery stage. I see. Yes, exactly.", "metadataJson": "{\"start\":4840,\"end\":4845}"}, {"text": "It also needs to record what it does, because if it, like, aborts, but the message never gets to, the coordinator. Needs to resend the same message. Right. Yeah. Well, it needs to record that it actually aborted that transaction id.", "metadataJson": "{\"start\":4852,\"end\":4866}"}, {"text": "So when the coordinator asks, what did you do? The next response would know. Got it. Thank you.", "metadataJson": "{\"start\":4866,\"end\":4873}"}, {"text": "Thank you. You're welcome. Thank you.", "metadataJson": "{\"start\":4877,\"end\":4881}"}, {"text": "See you all next week.", "metadataJson": "{\"start\":4884,\"end\":4885}"}]}