{"documentId": "lecture18", "section": [{"text": "Okay, good. Good afternoon. Can everybody hear me?", "metadataJson": "{\"start\":1,\"end\":6}"}, {"text": "Yep. Thank you. Yes. I will post the lecture notes at the end of lecture in response to the chat. Okay, so today, basically, I want to start with a new topic in, in 824, and sort of the last topic that we'll be discussing.", "metadataJson": "{\"start\":8,\"end\":31}"}, {"text": "The topic is really decentralized systems.", "metadataJson": "{\"start\":31,\"end\":34}"}, {"text": "And these are typically, the decentralized really refers to the fact that there's no single authority that is in control of the system. A lot of the systems that we've seen so far, all the machines and servers sort of cooperate and are under the control of a single institution or any single authority. And the systems a lot of you ask questions about, like, oh, how would it work if there's no central point of trust? And so from now on, the three systems or the three papers that we're going to be discussing are all sitting in this form of decentralized systems. And decentralized systems are harder to build than the sort of single trust systems because you have to account for byzantine failures or byzantine participants.", "metadataJson": "{\"start\":45,\"end\":97}"}, {"text": "And these are participants that sometimes follow the protocol and sometimes they don't follow the protocol. So really, to think about it, they're basically adversaries, and they may try to abuse or trick other protection systems for their own good, but not maybe for others. And so that makes actually system design or these distributed system designs much more challenging and much more difficult to reason about. We feel like in the last 18 whatever lectures, mostly where we talked about when we designed protocol or we thought about draft, we just assume that actually every participant in the protocol follows the rules. And with byzantine participants, that is not the case anymore.", "metadataJson": "{\"start\":105,\"end\":154}"}, {"text": "The participants can cook up new messages, send messages out of order, trick other participants. And so the thinking about those kind of protocols is much more difficult because we have to consider, like, what the adversary could do to sort of make our life, to break basically the properties of the protocols that we're shooting for. So this tends to be make the problem much harder.", "metadataJson": "{\"start\":155,\"end\":180}"}, {"text": "And really, what this sort of topic is, it sits on the intersection of distributed systems and security.", "metadataJson": "{\"start\":183,\"end\":191}"}, {"text": "And as we'll see in the next paper, in the next three papers for cryptography or security, ideas like signing and hashing are going to play a crucial role to actually make forward progress. In fact, the paper actually, that we're reading for today is also a paper that we use in 6858. If you take maybe six, five, eight. Last spring, we talked about this paper, too, although then mostly from the perspective of security today, I'm going to mostly focus. It is on the perspective of distributed systems, the sum itself.", "metadataJson": "{\"start\":195,\"end\":235}"}, {"text": "A lot of people asked, a lot of you asked, is sumder being used? And as far as I know, there's actually no systems that actually implement sumder directly or based in Sumner other than lab four in 6858. In lab four, if you do the lab four, the default project, which is lab four in 858, then you actually implement sumder. Now the reason, and so you might wonder why we're studying this paper at all. The reason we're studying it because it actually proposes a number of very powerful techniques or powerful ideas.", "metadataJson": "{\"start\":237,\"end\":277}"}, {"text": "And so particularly the same log, even though it is a strawman design or a conceptual design, is incredibly powerful. And you see back that same idea appear in lots of other decentralized systems, ranging from systems like git to systems like bitcoin or any other sort of cryptographic ledger, which we're going to be talking about Monday or next Tuesday. I know one system that actually is directly influenced by Sunder, which is a system called keybase. Keybase uses sumder techniques and many more. You're not familiar with Keybase that actually was recently acquired by Zoom, which you presumably are all familiar with.", "metadataJson": "{\"start\":280,\"end\":329}"}, {"text": "Okay, so that's sort of for the quick intro to this paper before I'll dive into more of the setting. Any sort of questions before diving a little bit deeper in the paper.", "metadataJson": "{\"start\":332,\"end\":344}"}, {"text": "Okay, so let's talk a little bit about the setting of this paper or the motivation of this paper. So the setting in that the officer set forward is a network file system.", "metadataJson": "{\"start\":350,\"end\":367}"}, {"text": "And you can think of this a little bit in the style of an earlier paper that we've read, Frank. The topic also was to implement in consistent network file system. So we have a file server, we have clients that interact with the file server. Somebody might actually create a file f and maybe read f another client.", "metadataJson": "{\"start\":371,\"end\":403}"}, {"text": "And the setting that we're in is that basically the file server as opposed to in French Pani, the file server server actually can be visited.", "metadataJson": "{\"start\":405,\"end\":418}"}, {"text": "And Byzantine really is created an extremely powerful threat model where, you know, gives the attacker an incredible amount of power. So in Byzantine, you know, the server might send different rpcs back, you know, cook up its own rpcs, take over the machine, you know, bribe the administrator and everything is basically, you know, the way to think about it is that the access area gets complete control of the file server.", "metadataJson": "{\"start\":422,\"end\":454}"}, {"text": "And so this covers sort of a wide range of more common attacks or like typical attacks that you might see in real systems or real attacks. One, bugs in software.", "metadataJson": "{\"start\":456,\"end\":467}"}, {"text": "So if there's a bug in the software. Then, you know, the asset area can exploit that bug, maybe to obtain privileges. And, you know, the visiting model, you know, completely compasses that. Or, you know, the system administrator might have a weak, with a weak password, the attacker compromises and then, you know, takes control over the system. You know, that's also covered by physical breaking.", "metadataJson": "{\"start\":471,\"end\":503}"}, {"text": "Maybe the attacker ranger gets access to the physical machine and can therefore control the physical parts of the machine. Again, that's all covered by this byzantine threat model. Or even maybe the attacker bribes an operator or colludes with a malicious client that is also covered by this model. So this is a threat model that is very, very, gives a lot of power to the adversary and covers a lot of sort of standard attacks. And, you know, the first thing sort of observed, you know, again, that some, their place is that instead of actually, you know, sort of maintaining the whole file system on the file server, the file server is as simple as possible.", "metadataJson": "{\"start\":508,\"end\":568}"}, {"text": "And in fact, you know, the file server is very much like, almost like pedal. It's almost like a block device with a little bit more.", "metadataJson": "{\"start\":568,\"end\":575}"}, {"text": "So there's sort of a central place where all the blocks are stored and but the clients really implement the file system. So it's not really that the client sends a create profile. It actually sends blocks and reads blocks from the block server and basically constructs from the blocks that reads and write its own view of the file system and serves file system operations basically on straight on the client. And so here really we have created, read f, et cetera. So very, very similar to the frontier, except, you know, the big difference in Francipani is that petal and all the clients were completely trusted.", "metadataJson": "{\"start\":578,\"end\":624}"}, {"text": "And in this setting, the clients are not trusted and the file surface can be also not trusted. Okay.", "metadataJson": "{\"start\":624,\"end\":634}"}, {"text": "Okay. So the paper focuses on a particular set of security properties. And the focus is really on, the focus is on what is called integrity properties.", "metadataJson": "{\"start\":641,\"end\":657}"}, {"text": "And in contrast to confidentiality. So confidentiality is about protecting data from so that nobody else can read it. Integrity is just ensuring that the system structure is correct and the modifications, illegal modifications to the data are being detected. And whether the data is public or not public, that sort of decides the point here to make it a little bit more concrete. What they're sort of, the thing that they have in their minds is we have a set of, we have developers, Dev one, you know, Dev two, they may share, you know, some machine that contains the source code repository of some, you know, source, some project.", "metadataJson": "{\"start\":660,\"end\":705}"}, {"text": "The developers, you know, are collaborating on that project and, and sort of think about this as you know, the example that the paper mentions is in the paper. Maybe this is the development machines and server for Debian Linux. And what they want to again defend against is trapdoor. Trapdoor?", "metadataJson": "{\"start\":705,\"end\":728}"}, {"text": "Trapdoor in the software.", "metadataJson": "{\"start\":732,\"end\":733}"}, {"text": "So the attacker takes over control, breaks into the machine that contains the source repo. Modest, buys the software unnoticed. And then at some point that software gets deployed. For example, Debian Linux gets deployed to lots and lots of machines. And now the attack has control over those machines because it can exploit the trapped one.", "metadataJson": "{\"start\":736,\"end\":762}"}, {"text": "The paper talks about this attack, this particular instance of Demi Linux in 2003, where an attacker was able to compromise the development server or cluster. And recovering from these kinds of attacks is very painful. In fact in 2003 they report that the Debian Linux froze development for a couple of days while they were trying to sort out which parts of their source repo were still correct and which part were actually modified by the attacker. And these attacks happened periodically. Last year Ubuntu had a similar type of problem in 2018 or 2019, I can't remember exactly.", "metadataJson": "{\"start\":764,\"end\":809}"}, {"text": "And it was a similar case where one of the core development servers was broken into and you know, they have to sort of sort out what were see which software, which files got affected by that breaking. Okay, so that's sort of the setting of the, of the paper. And I'm going to make it a little bit more concrete, a little bit of a toy example to help us go through the techniques that this paper actually uses.", "metadataJson": "{\"start\":809,\"end\":841}"}, {"text": "So the example that I'm going to use, partially inspired by 6858, is, let's say we have a file system, you're doing the. And the file system contains the source code for this application that we use in 858 called Zubar. And Zubar is sort of a virtual bank type application where users of the system, registered users of the systems can transfer zubars to each other. And so it has a file called auth Py that does authentication. And it has a file that basically implements the bank UI.", "metadataJson": "{\"start\":844,\"end\":890}"}, {"text": "Let's consider the case where we have a new set of developers, A, B and C. And you know, they decided that they want to sort of increase the usability of Zubar and actually deploy it for real. And to make it real. Basically, you know, they decide to divide the work as follows. A is going to modify off UI to support MIT certificates, MIT certs, kerberos ticket or certificates.", "metadataJson": "{\"start\":894,\"end\":931}"}, {"text": "And with the idea that what they're going to do is, you know, the off Bi is going to be modified so that only legit MIT community members actually can log into the file server or into Zubar. And so that we actually know who it actually really is that is associated with that particular MIT certificate. And then to make it a little bit more useful, b is going to actually modify the dank py to actually link it to cache stack or cache. And so the idea that basically we can actually use the Zubar system, of course you should never do that, but we can use the Zubar system to actually transfer money, real money, instead of zubars, between users that are registered with this service. Now this sounds of course, like a crazy idea and you should not really do it, but it's not completely ridiculous because the off PI really checks who it actually is based on the MIT certificate.", "metadataJson": "{\"start\":931,\"end\":996}"}, {"text": "And so maybe it's not unreasonable that we could connect back to POi to actually tech cache. And then basically, you see, in our scenarios, is going to be the person that is actually going to deploy the software, find the machine, takes the software, installs it there and runs it, and opens it up to the MIT community. Now in the case, let's consider what could happen, what could go wrong if actually the file server was compromised and so it's visited.", "metadataJson": "{\"start\":996,\"end\":1032}"}, {"text": "Well, the obvious, you know, problem, there's a couple of obvious problems, you know, bad outcomes possible. So let's consider them, you know, bad outcome one, which is the one that we should be talking about in also in the previous examples, is, you know, basically the adversary gives arbitrary code to circle. So adversary provides own code to see that's sort of the, or maybe the answers are slightly subtle about it or clever about it, you know, whatever makes it a little bit hard to spot that actually modified Auth PuI, for example, to delete the MIT certificates. But there's basically, there's really no way for C to check that. Actually it got the software that a and B produced without any modifications from the adversary.", "metadataJson": "{\"start\":1036,\"end\":1097}"}, {"text": "So that's the obvious problem. We're going to talk a lot about it. Then there's a second sort of bad outcome, which may be a little more subtle, which is that the adversary provides the changes to Gangweb Pui without the changes to auth Py.", "metadataJson": "{\"start\":1097,\"end\":1125}"}, {"text": "And so at this point, this is pretty problematic, right, because bank PPI is linked to tech cache now, but we actually don't have appropriate authentication of users anymore. In fact, anybody that actually creates a Zubar account can now actually interact with Tackash. And so clearly very, very undesirable and harder to spot because basically the accessory actually doesn't really modify any software. I just selectively presents and takes pieces of it and presents that to see who then actually goes off and deployed. And so it's really, of course, the tax the paper considers is of course attack number one too.", "metadataJson": "{\"start\":1127,\"end\":1174}"}, {"text": "But you know, a lot of, some of the subtle issues actually are brought out by this sort of second case that we'll be talking about.", "metadataJson": "{\"start\":1174,\"end\":1181}"}, {"text": "Any questions so far, you know, about the setting and by the motivation and before I gonna try to discuss solutions. So the problem with the second case is that the user that they, the authentication does not authenticate. Yeah. It doesn't use the MIT certificates anymore and so we don't really know actually who logs in. Thank you.", "metadataJson": "{\"start\":1184,\"end\":1213}"}, {"text": "What about the case where a or like b won't see a's like the fork?", "metadataJson": "{\"start\":1215,\"end\":1222}"}, {"text": "Let's assume for a second that a and b actually, you know, have talked to each other and divided up the work. So they know that they're supposed to be doing this together.", "metadataJson": "{\"start\":1225,\"end\":1232}"}, {"text": "I mean they form a team, they're in close collaboration and contact, you know, and they've divided up the work. And so they know, you know, b tells a when he's done, b tells a when he's done, and then they tell C. Go ahead, we're all done. Okay. Okay.", "metadataJson": "{\"start\":1235,\"end\":1252}"}, {"text": "So let's start with considering a simple design that is too simple, meaning it doesn't work, but it gives us some starting points for a more sophisticated design that hopefully might work. And so the simple plan is that a and b, or any, all the files are going to be signed with the person who modified it. When like a modifies, you know, off py, a actually produces a signature and signed with the public key signature assigned to the public key of a. And you know, that signature covers the data of the file.", "metadataJson": "{\"start\":1252,\"end\":1308}"}, {"text": "And so when c downloads the auth, py checks the signature.", "metadataJson": "{\"start\":1311,\"end\":1319}"}, {"text": "And if the signature checks out, then c knows that actually this file was produced, this file was induced produced by a. And you might all believe that things are good and that's the basic plan. And we'll talk a little bit about where the keys are coming from. Although the issue of sort of public key distribution is really an 858 topic, so I'm not going to talk too much about it, but just assume for now that every user has a key public key pair, and the private keys are keep secret and the public keys are public. And every user knows whose public key belongs to who.", "metadataJson": "{\"start\":1325,\"end\":1363}"}, {"text": "So now let's consider some attacks and see which ones sort of, you know, fail which ones, you know, work. So of course the obvious attack was number one that we talked about on the previous slide, which s modifies files, and that is not a little bit, that's not directly s modifies Autocpi, that's not really going to be possible anymore, because when Ce downloads the file and the signature and checks it, and it will see that the signature doesn't check because the data that actually was signed is different than the data that actually the server produced. It's not really possible for the server really to modify auth PUI without actually being attacked or BV being detected. So, you know, this is, we're sort of in good shape here on this attack, and that's sort of the core attack, right. But there's a lot of other things that s til could do.", "metadataJson": "{\"start\":1365,\"end\":1430}"}, {"text": "And so let's consider some of the other things. S, you know, could actually, in the way I described, s could send another file and pretend to be off pyro. And because the signature doesn't really say which actually file the data belongs to. And so s could just, you know, produce some other file and say like, oh yeah, see, this is actually off the py because, believe me, and here's the, you know, the science. Here's the signature that was of course produced by s.", "metadataJson": "{\"start\":1431,\"end\":1465}"}, {"text": "So of course this could be fixed. You know, maybe the signature should not only include the data, but it also probably should include the file name. So, you know, maybe not too bad. And something that could be addressed a third, you know, another, yet another possibility is to, for us to basically send the contents of old files or old content and maybe some new.", "metadataJson": "{\"start\":1465,\"end\":1496}"}, {"text": "And that's a little bit more difficult now for us to handle correcting this too simple plan because there's no way, basically the files are infinitely authenticated but not together. It's not that c gets a consistent picture of the file system, it just gets like signed files. And how those signed files relate to each other in terms of their histories is completely not covered in this too simple design. This is exactly, of course, the issue. There's more subtle attack that now could just completely work out because s could send the old version of authentic Py and will completely check out and then send the new version of the bank Py, which actually talks to his link to tech cache.", "metadataJson": "{\"start\":1503,\"end\":1555}"}, {"text": "And now we're exactly back in the worst case, where we have an old version of Auth UI or not to change it to off Py, not the certificate changes to off the, and the new version that actually linked to tech hash. And so this is not so good. So the simple point that we have here just doesn't deal with this, there's a similar sort of another sort of version of this that where of course s can also just claim that the file doesn't exist and c doesn't really have any way of checking whether that actually is true or not, because again, it doesn't have a global picture where it's a consistent view of the file system. It only knows about signatures for each file. And so you can see that there's the simple design, maybe a good starting point, but we need something more, more complete.", "metadataJson": "{\"start\":1555,\"end\":1614}"}, {"text": "In particular, we need something that really ties all the file systems, all the files together, that ties the directories together, the content of the directories together, and you have to be able to decide in some way what is the latest version of the file system. And so that c can't be tricked into in this problematic case where one file is installed and the other file is not installed. So that's really what some of the paper tries to address.", "metadataJson": "{\"start\":1614,\"end\":1642}"}, {"text": "And the big idea in the paper, and this turns out to be just a big idea in general, and it's a conceptual idea. Even though the paper actually doesn't really implement this big idea directly, it implements it in a more indirect way. It is an incredibly powerful idea. So the big idea is to have a signed log of operations.", "metadataJson": "{\"start\":1646,\"end\":1675}"}, {"text": "And of course, you know, you're well familiar with locks of operations and you know, you can, and this is basically a sort of a beefed up version of it where there are signatures on the lock entries that both consider cover the entry as well as preceding entries. And this turns out to be, as you've seen in all the previous distributed systems and failure recovery protocols we talked about, the log is actually a very powerful idea to think about the correctness of the system, and in the same way that the idea is carried forward here in this byzantine context. And so let me draw in a simple logic.", "metadataJson": "{\"start\":1681,\"end\":1724}"}, {"text": "So block whatever has some entries, and let's say, you know, we're covering the operation that we are talking about. So there's a modification mod, you know, off by a and signed by a. You know, there's a mod if everything goes well, you know, there's a mod of the bank py signed by b.", "metadataJson": "{\"start\":1728,\"end\":1757}"}, {"text": "And as we'll talk about in a second, you know, it turns out that not only are the modifications in the log, but also the fetch. So the read operations.", "metadataJson": "{\"start\":1760,\"end\":1769}"}, {"text": "So fetch, fetch the log by C, fetch of auth Py and the fetch of ping Py signed by C.", "metadataJson": "{\"start\":1771,\"end\":1789}"}, {"text": "We'll talk about those operations of the fetch operations a little bit. I first, want to talk about the preceding operations? First, the modifications.", "metadataJson": "{\"start\":1792,\"end\":1801}"}, {"text": "So, first of all, what is important to realize is that the signature that is in the record not only covers the record, the current record, but it also covers all the records before it.", "metadataJson": "{\"start\":1805,\"end\":1817}"}, {"text": "Let me stop for a second here, because I'm not 100% sure if actually, can everybody still hear me? Yeah. Yes. Okay. My iPad logged out of the zoom session.", "metadataJson": "{\"start\":1823,\"end\":1835}"}, {"text": "I was logged in twice, and my iPad logged out. So I just want to make sure I'm still talking to you and you can hear me. And so that is the case. Okay? So let's just proceed.", "metadataJson": "{\"start\":1836,\"end\":1849}"}, {"text": "So what I was, I think we lost Franz. It.", "metadataJson": "{\"start\":1851,\"end\":1882}"}, {"text": "Can people hear me now?", "metadataJson": "{\"start\":1924,\"end\":1926}"}, {"text": "Does anybody hear me? Yeah. Yes. Okay, good. Okay.", "metadataJson": "{\"start\":1928,\"end\":1934}"}, {"text": "I don't know if anything weird happened on your end, but on my end, I got logged out of zoom and logged back in.", "metadataJson": "{\"start\":1934,\"end\":1942}"}, {"text": "Maybe there's a byzantine server at work.", "metadataJson": "{\"start\":1944,\"end\":1947}"}, {"text": "Okay, let me hold on 1 second and get myself in.", "metadataJson": "{\"start\":1949,\"end\":1955}"}, {"text": "Let me.", "metadataJson": "{\"start\":1970,\"end\":1971}"}, {"text": "Okay. Let me know if I'm good.", "metadataJson": "{\"start\":1988,\"end\":1991}"}, {"text": "Okay, good. No screen sharing yet, but, yeah. Okay. I hope this works out better. Okay, so I was at this very important point where the signature does not cover the log entry itself, but also covers all the preceding log entries.", "metadataJson": "{\"start\":1994,\"end\":2011}"}, {"text": "And so when a adds this modification to auth py to the log, it signs the log record itself plus the preceding log record. And you can think about this, that the preceding log is maybe represented by the content of the preceding log is a cryptographic hash. And in the record, basically, of the modification to off people, I, the cryptographic hash of the preceding part of the log is included and covered by the signature. Just to be clear, we still can't see the screen. Can't see the screen.", "metadataJson": "{\"start\":2012,\"end\":2048}"}, {"text": "Okay, good. The screen hasn't changed yet, but let me see if I can do something about that. Oh, yeah. I guess my zoom still thinks that there's actually sharing the screen with. It doesn't look like it actually is.", "metadataJson": "{\"start\":2048,\"end\":2065}"}, {"text": "How about this? Yep, I can see now. Okay, thank you. Okay, so I didn't change anything yet other than I think I was going to draw the next arrow, which basically when b signs, you know, it's actually carving all the preceding entries too. And this is sort of good, correct?", "metadataJson": "{\"start\":2075,\"end\":2091}"}, {"text": "Because when the client C actually receives or gets, actually sees the log entry for b, then it's impossible for the server to drop the log entry of a because that will be detected when C actually detects a signature on the log entry of b. We already made a big step forward in the sense that it's much harder for the server now to selectively draw block entries. So then we're in pretty good shape. The server cannot drop a and keep these modifications.", "metadataJson": "{\"start\":2091,\"end\":2141}"}, {"text": "So that's actually a big, big step forward. And so let's look a little bit more in detail how this actually is going to play out. So we're the client C and you know, we're fetching the log to basically rule out the distribution of the software or to install it on a particular machine. The first thing the client does, it actually checks all the signatures.", "metadataJson": "{\"start\":2144,\"end\":2166}"}, {"text": "And always the question of course is like when you want to check the signal of the log entry, you know, which public key do you use? And because you want to make sure that you're not being tricked in accepting a signal, a modification by a. But it turns out that actually a was not the person actually who signed it. And it turns out that basically to figure out like which key to use to actually verify the signature, the key you use is the owner of the file. So the public key needs to correspond to the owner of the file and ignoring groups for now.", "metadataJson": "{\"start\":2173,\"end\":2212}"}, {"text": "You know, basically only the owner of the file is allowed to modify a file. So for this simple, slightly simplified, you know, we can think about it off. The PI is owned by a and the id of the file is basically the public key of a. And so we know which public key to use and can verify the signature with it. And so if somebody else makes a modification that pretends to be a, that actually is not going to check out.", "metadataJson": "{\"start\":2213,\"end\":2242}"}, {"text": "So it's really only a that can actually make the modifications and similar for B. So that's part of the, you know, one thing that's actually clever about sumder, which I'm not really going to be talking about in some sense, the file system is actually doubling both as a file system and as a public key, public key infrastructure, distribution infrastructure. And so it is actually possible to use some that basically reliably determine like, you know, which user has which public key. But I'm not really going to talk about this. I really want to focus on the consistency aspects and of more distributed systems aspects.", "metadataJson": "{\"start\":2243,\"end\":2280}"}, {"text": "The second thing that the client does is check its own last entry.", "metadataJson": "{\"start\":2280,\"end\":2287}"}, {"text": "And this is to protect the client from actually being rolled back by the server in time. So the server can't actually by the client checks always his last entry. If his last entry is in the log still, then the only way forward for the attacker is to actually roll the file system forward. It can roll backwards. So C will check whether any of its previous operations are in it and confirm that they're still in it.", "metadataJson": "{\"start\":2293,\"end\":2318}"}, {"text": "Actually it's last entry still in it. Just a question here. Yeah. This only, I think this attack from the server to rollback would only work if no other client wrote to the log after this client's last entry. Right.", "metadataJson": "{\"start\":2319,\"end\":2340}"}, {"text": "Because otherwise checking signatures would figure that out. Yeah. Although let's talk about it in a second. Maybe. You can always play a fork attack, so you can always split the view of the files within the multiple views, but you can at least not grow back the clock once the client saw a particular file system.", "metadataJson": "{\"start\":2340,\"end\":2361}"}, {"text": "You can't go backwards in time. Now the server can present different file systems in the future, but you can draw back third part. The third part is construct a file system so after it knows that actually it's not a rolled past version of the file system, it basically applies all the modifications and basically builds a file system tree on the client and then performs whatever operation it is it wants to perform. So let's say in the case of c, what it will do is it will read off by and append an entry to the log and sign it.", "metadataJson": "{\"start\":2361,\"end\":2415}"}, {"text": "So in the case when it reads auth py, it will produce basically a signature, an entry for this log entry. And basically then the final step in this protocol is it uploads the log to the file server.", "metadataJson": "{\"start\":2417,\"end\":2432}"}, {"text": "Clearly this protocol is completely impractical. And really what it is, it's sort of more a conceptual protocol to help us understand why actually we might even be successful in achieving security in the context of byzantine server because it would be ridiculous to download the log for every operation and the log contains the history of all the operations ever happened to the file system. In step three, the client actually constructs a file system that all the operations ever perform and since the beginning of time, and then finally in step five uploads the whole log back to the server. That seems completely ridiculous, and it is ridiculous in terms of performance, but it will help us understand when we look at the implementation of a scheme where it actually has the same set of properties that this conceptual design has. We'll see later.", "metadataJson": "{\"start\":2438,\"end\":2492}"}, {"text": "For example, in the case of bitcoin that literally does actually have a log since the beginning of time with all operations in it. And so maybe it was a crazy idea, maybe in the context of 2004, but you know, people actually do have these sort of signed logs and really maintain them. And so in that sense, you know, it's not only a big conceptual idea, actually people do it in practice.", "metadataJson": "{\"start\":2493,\"end\":2515}"}, {"text": "Any questions so far?", "metadataJson": "{\"start\":2518,\"end\":2519}"}, {"text": "Okay, so the one thing that you're probably wondering about, and that was proposed as a question for the reading today, is what is up with these fetches? Why are the fetches in the log? Two, because you might think, well, the only thing that we really care about, if we think about what we care about, is that only the modifications have to be in the log because there are actually other things that actually modify the file system. We don't really modify this file system. So what's the problem?", "metadataJson": "{\"start\":2524,\"end\":2559}"}, {"text": "And so I think I want to do a quick breakout here and sort of you can brainstorm each other about what you thought the answer to this particular question was. And hopefully maybe sort of this initial coverage of like Sumner, you know, maybe hasn't now improved your understanding and you can sort of figure out like what the answer is or talk about something else. So I would like to take a, you know, maybe do a five minute breakout room.", "metadataJson": "{\"start\":2561,\"end\":2587}"}, {"text": "It just double checking everybody back. Looks like it. Thank you. Okay, so what are I guessing? Let's start with the homework questions.", "metadataJson": "{\"start\":2604,\"end\":2968}"}, {"text": "With the homework question. Why do, why are the factors in the log?", "metadataJson": "{\"start\":2968,\"end\":2972}"}, {"text": "Anybody?", "metadataJson": "{\"start\":2978,\"end\":2979}"}, {"text": "If you have a read only server, if there are no fetches, the file system can give it anything. Give it, because it, because there are no fetches in the log. That would mean that the read only servers would not be doing a lot of the checks that we talked about before. So the go back in time, for example, might maybe not work because it did not put anything in the log. Because it only fetches.", "metadataJson": "{\"start\":2981,\"end\":3015}"}, {"text": "Yeah, yeah. Okay, good, good. Okay, so I think you're totally on the right track. It's like trying to make it a little bit more precise or more concrete. I think that is correct.", "metadataJson": "{\"start\":3015,\"end\":3025}"}, {"text": "So let's assume this is the log looks like and the C fetches are not in it. And let's, you know, so this is the log before actually C downloads the log. And so let's say, you know, we're c fetcher, such as off the py. This is a file that was modified by a. And basically what the server does, the server, instead of actually providing both the modifications a and b because it has it, which a and b were done with its modifications, it sends the c basically prefix, since the prefix that excludes the modifications to a and b.", "metadataJson": "{\"start\":3025,\"end\":3076}"}, {"text": "So without mods a and b.", "metadataJson": "{\"start\":3076,\"end\":3080}"}, {"text": "Right. And so C, you know, fetches this file, fetches the log. So basically it's this part of the log. Here's a prefix.", "metadataJson": "{\"start\":3082,\"end\":3090}"}, {"text": "She checks the signatures, checks whether its preceding operations are in it, and they're all there because she hasn't done any other operation yet. And so basically it will accept the log, the log as it is, or the prefix as it is, and basically returns off the py to whatever application that is copying the software into the machine that actually is going to run the installed software. So then C fetches bank py, and this time around the server sends the whole log.", "metadataJson": "{\"start\":3094,\"end\":3134}"}, {"text": "And you know the circle, she looks at these entries. It's a valid log. Its own operations are presumably in the prefix. Since we didn't care about fetches, it's of course not in the log. And so everything looks good.", "metadataJson": "{\"start\":3139,\"end\":3157}"}, {"text": "These are valid modifications. Nothing has been changed without the fetches in the log. Civil actually accept this logic and basically build a file system that has, that includes the modifications to the a and b and returns the result to the application for bank Py so that it can install it on the machine that actually is going to run the service. And as you can see now, we're sort of in a bad situation because we took the old version of off Python and the new version of Banker two Pui. And the one way you can think about this is that from C's perspective, what really seemed to be that happened is that while it was reading off by, there were concurrent modifications to a and B, and this happened basically at the same time, or at least the server is pretending it happened at the same time, same time.", "metadataJson": "{\"start\":3158,\"end\":3225}"}, {"text": "And so it gets confused or it can detect that in fact these applications were, did happen before in time. So this is the problem that basically putting the fetches in the lock solves. And let's make that actually just also concrete and so see why actually this problem is solved. In that case, I had a question. Yep.", "metadataJson": "{\"start\":3225,\"end\":3256}"}, {"text": "So I have a little trouble understand like understanding what the, like, sort of like the interface for like for fetch and modify is. Like what I thought you fetched pretty much like the whole tree and had to rebuild the whole file system. Basic example, but the slide before you're fetching like specific files, the server is the one that returns the log. Correct. Right.", "metadataJson": "{\"start\":3257,\"end\":3289}"}, {"text": "So the server can decide what entries to include. Yeah. And we already seen that it can, it can't really delete anything out of the middle of the log. Right. That's not really possible.", "metadataJson": "{\"start\":3289,\"end\":3298}"}, {"text": "We send a prefix of the log because the prefix is always consistent with itself. Yeah. And so in this first case, correct, it sent the prefix and in the second case it's in the whole log. Yeah. And so the server can decide to do that.", "metadataJson": "{\"start\":3299,\"end\":3314}"}, {"text": "Right. There's like nothing that the client can, or at least like so far, you know, discussed, there's nothing that the client, how the client could detect that it didn't get like the whole log. Right, right. My question is more towards like what the interface is for clients to use, like fetch and modify. Like, like, because I thought, initially, I thought, okay, like fetch fetches like the whole file system.", "metadataJson": "{\"start\":3314,\"end\":3336}"}, {"text": "No no no, fetch is a single file, okay? And so basically what a fetch does is it gets the law, like the modifications, fetch, okay, so modifications are all the operations that modify the file. And like if you go back to a slide a little bit earlier, you know, in the modification record, it sets explicitly which file is being modified and you know, what's being cited. Similarly, in the fetch, actually it says with file, actually this client saw. Okay, and then, so, so for a fetch, like a client goes through the log but only looks at, yeah, the final thing it does is actually read the file that actually is looking for.", "metadataJson": "{\"start\":3337,\"end\":3376}"}, {"text": "Okay, but does it check every single entry in the log anyways for the signature or. Yeah, yeah, yeah. Okay. The first step is always check the whole log and make sure that your last, you know, operations in it, whether it's a fetch or a modify. Although in this broken scheme we drop the fetches, it applies all the checks, all the signatures, and then it builds up the file system by replaying the log from the beginning of time and get a file system.", "metadataJson": "{\"start\":3376,\"end\":3406}"}, {"text": "And then it does its operation. And so in this case the operation is actually fetch off. Py is basically reading it. Okay. The reason basically we talk about fetch and modify is because all operations are basically following one or two camps.", "metadataJson": "{\"start\":3406,\"end\":3418}"}, {"text": "Either it's a fetch or it is a modification operation, like writing a file, creating a file. These are all modification operations. The fetch operations are reading a file, maybe ls and directory stata file, that kind of thing. Okay. And then the modify is also like a modify.", "metadataJson": "{\"start\":3418,\"end\":3439}"}, {"text": "Like doesn't fetch also fetches the log but then, and builds the file system? Yeah, yeah. So maybe the fetches. Here, I'm using fetch, I guess in two ways. One, to describe read only operations and actually to get, you know, to obtain or receive the log from the server.", "metadataJson": "{\"start\":3439,\"end\":3455}"}, {"text": "Okay, but then modify modifies also one single file. Yes. Yeah. For every modification in the file system, you're going to have lock entry. Okay, thanks.", "metadataJson": "{\"start\":3456,\"end\":3467}"}, {"text": "Sorry. I also, I have a question. I don't really understand why this scenario is a problem. Because as you said, it's possible, like from the perspective of the client, it may well be that AMb got created or modified from the last fetch. Yeah, in principle it could have happened.", "metadataJson": "{\"start\":3468,\"end\":3491}"}, {"text": "Correct. It was a core modification. We do know because we were sort of look from the top and we know that basically c read the file after a and b modified it. But the server can pretend as if it actually happened concurrently. And in a second we'll see that if we stick the fetches in the log, the server cannot pretend to do that.", "metadataJson": "{\"start\":3491,\"end\":3511}"}, {"text": "Okay, but even if the server pretends that, does it even, is that even a problem? Does it break anything? Because the client can only. Yeah, this is the example where it shows how to break something. Correct.", "metadataJson": "{\"start\":3513,\"end\":3526}"}, {"text": "Like step one, Cfetches auth py. The server gave it one as part of the fetch, it gave it the prefix. And so the client constructed the file system, executed the operation, returned auth Py to the application that installed the software on the machine, just to make it very crisp. So now the first reading off the py, that operation is done, finished, already executed, and has installed the old version of off py on the machine. Then the client fetches bank py.", "metadataJson": "{\"start\":3526,\"end\":3562}"}, {"text": "Now the server, actually, the application wants to read bank py. So the client fetches the log from the server, or asks the server, please give me the log. The server this time around gives the whole log and not just the prefix. Yeah, but client builds up the whole file system and returns bank py to the application. But wouldn't this happen in an incorrect implementation of the client?", "metadataJson": "{\"start\":3562,\"end\":3590}"}, {"text": "Because if the client finds that, receives the log, and it sees an additional modification on a, if the client knows that its logic depends on a and b being in sync, it would also fetch a again. Yeah, yeah, yeah. Okay, so there's a great question. C doesn't know. Correct.", "metadataJson": "{\"start\":3590,\"end\":3608}"}, {"text": "That is C. Okay. In this particular scenario, we're trying to establish whether actually c can determine whether actually the modification happened concurrently or in the past, before Reddit. Now we want to be in the case that it actually happened in the past because it actually really happened in the past. But what this server does, it just pretends that the modification actually happened concurrently.", "metadataJson": "{\"start\":3608,\"end\":3638}"}, {"text": "We have actually c operations, and C doesn't really have any way to detect that other than a new, maybe that there should have been a modification for a and b together, but that only could have known if there were sort of communication between c and a and b. Let's talk about that in a second. But if C had not talked to a and b, then, you know, it could have gotten, could ended up in this scenario where it installed the old version and off py in the new version of bank py. And we'll see in a second. If we stick the fetches in, then this problem just cannot happen.", "metadataJson": "{\"start\":3638,\"end\":3674}"}, {"text": "Somebody asked, if we timestamp everything, then, you know, we could detect things. Hold that thought for a second.", "metadataJson": "{\"start\":3677,\"end\":3683}"}, {"text": "Okay, let's look at the, the vid fetch scenario, right? So see what actually happens in that case. So client fetches when it's the fetcher of off py.", "metadataJson": "{\"start\":3685,\"end\":3698}"}, {"text": "Oops, what happened now?", "metadataJson": "{\"start\":3701,\"end\":3703}"}, {"text": "Hold on a sec. Something went wrong. I presume. Nobody can see my screen yet. Nobody can see my screen.", "metadataJson": "{\"start\":3709,\"end\":3716}"}, {"text": "It's block. Yeah, yeah, it's coming back. Hold on a second.", "metadataJson": "{\"start\":3722,\"end\":3726}"}, {"text": "I definitely feel today there's a byzantine component to 824.", "metadataJson": "{\"start\":3730,\"end\":3735}"}, {"text": "Let me just stop sharing the screen for a second.", "metadataJson": "{\"start\":3752,\"end\":3754}"}, {"text": "All right, we're back, hopefully. Okay.", "metadataJson": "{\"start\":3801,\"end\":3805}"}, {"text": "Okay, so back to this example where now the fetches are in the log. C fetches, the auth py. Actually, let me continue with, let me save this for just fetch off py, the server sends the prefix.", "metadataJson": "{\"start\":3812,\"end\":3837}"}, {"text": "So basically it sends these modifications, correct, because the server can just return whatever it likes. Then in this new plan, correct, where the fetch is actually are being logged, then c constructs the file system using a and b, and then returns that of course off py to the client or to the application. And then it adds a fetch to the log and uploads that log to the server. And then, you know, the fetch off bank pui and you know the server. You know, in our previous example, the, so first example, just the prefix.", "metadataJson": "{\"start\":3843,\"end\":3900}"}, {"text": "Here's the prefix.", "metadataJson": "{\"start\":3901,\"end\":3903}"}, {"text": "Now the client sends the whole thing, so it sends the whole log, but the modifications are not in it. And we'll have to send the whole log. Well, to send the whole log it must include the fetch from c. Correct. And so if it doesn't, you know, sent the fetch receipt, it actually sees that the c is not, actually not there, the read operation.", "metadataJson": "{\"start\":3905,\"end\":3939}"}, {"text": "And basically the client will reject the log because actually its own fetch operation is actually not in it. So it is not possible for the server to pretend, you know, that, to send the log later on because actually the new log should have included that fetch operation that was in it. And the C or the server cannot splice that fetch operation into here to make it consistent what actually happened before, because that would be detected because the modifications on the records of a and b are not, wouldn't check out.", "metadataJson": "{\"start\":3939,\"end\":3976}"}, {"text": "Okay, so basically what this really does is to sort of step back is that you can think about this attack that the server sort of pretends that the modification to a and b happened concurrently with the c reading it, even though we know that actually is not the case. And by sticking the fetches in it, that attack cannot happen.", "metadataJson": "{\"start\":3978,\"end\":3999}"}, {"text": "I have two questions, maybe. First, just if you could like define for consistency and the fetch modify consistency. And then the second is in this example. So what exactly is stopping the server from placing the fetch in the right place of the log? Because remember, every log entry covers all its proceeding entries.", "metadataJson": "{\"start\":4003,\"end\":4029}"}, {"text": "Okay, so if, if, for example, so the server could not splice that, you know, fetch, you know, after the prefix, before the modifications of a and b. So let's say it only wants to send the modification of a. It knows the hash of the modification of a and everything preceding it. And then it could insert like the fetch to see there because it knows that it could say hash of that. Yeah, but then it could send that.", "metadataJson": "{\"start\":4029,\"end\":4052}"}, {"text": "Yeah, but then it couldn't send the modification to b because the modification would be, you know, is directly after a and so a must. And so you can't splice it between a and b either. I see, okay, sorry. And what was the problem with having it where it is in the picture?", "metadataJson": "{\"start\":4052,\"end\":4073}"}, {"text": "Well, where it is and now in the picture is perfect. It's fine. Right. And in fact, you know, this basically suggests, you know, that the fetch of C actually included the modification of a and b. Like the blue was the real log and we have the fetch and C in it and you know, the, everything is going to be perfect.", "metadataJson": "{\"start\":4075,\"end\":4091}"}, {"text": "So just to clarify, the definition of fork consistency. Yeah, yeah, hold on, hold a second. This is the topic of this slide. I haven't talked about the definition for consistency yet. I'm going to do that right now.", "metadataJson": "{\"start\":4098,\"end\":4109}"}, {"text": "Okay, so we're talking about for consistency.", "metadataJson": "{\"start\":4110,\"end\":4115}"}, {"text": "So what we've seen, right, so far is that the server cannot really manipulate the log. It can only sort of send prefixes or can hide parts. It can hide, it can send the prefix back to the client, but it can't really modify the log. So it just basically has an opportunity to show different logs to different clients. And that is basically what for consistency is.", "metadataJson": "{\"start\":4123,\"end\":4150}"}, {"text": "And so it cannot provide the kind of, the server cannot provide the type of consistencies that we've seen so far in the past, namely like linearizability and external consistency and things like that. That's just not possible. But it can provide this. What the paper calls or introduces is for consistency. And let me abstract a little bit away and explain what that is.", "metadataJson": "{\"start\":4150,\"end\":4170}"}, {"text": "So let's say we have client a, we have the server s and it has a log.", "metadataJson": "{\"start\":4170,\"end\":4177}"}, {"text": "Let's say, I'm just going to abstract everything away. It has entries a, B, C and D and e and a whatever. Maybe panda data entry to the log and that's basically it. And maybe we have another client b. And what the server can do is give the other client a completely different view of the world by basically have another copy of the log or its own copy, or give it a different copy of the log.", "metadataJson": "{\"start\":4179,\"end\":4214}"}, {"text": "For example, maybe that log contains the record a. But then every operation that B does goes into this log. B, one, b, two, maybe even some operations from other clients that also get this view end up in this log, but they're not actually shown to a. Basically a might actually also add more entries to the log. Like maybe it had b, C, D and E.", "metadataJson": "{\"start\":4214,\"end\":4236}"}, {"text": "And those are not actually shown to b. So these two logs to the world view of a looks completely consistent because it's unaware of any of these changes. And to be this log looks completely consistent because it's not really aware of any a changes, right. Because in this model of the world, the only shared communication place that is there is the server. That is sort of the thing that shows what actually is the state of the system.", "metadataJson": "{\"start\":4236,\"end\":4267}"}, {"text": "And one way you can think about it is in terms that we've talked about before, this is sort of like a split brain.", "metadataJson": "{\"start\":4268,\"end\":4273}"}, {"text": "Basically, a gets the c one view of the world cooked up by a log that's consistent with a's view, and b gets another view of the world. And basically the server keeps them carefully separate and therefore can pretend that a is looking. One sees the left side of his brain, b sees actually the right side of S's brain. Okay, does that make sense?", "metadataJson": "{\"start\":4276,\"end\":4306}"}, {"text": "So that's sort of what basically they're saying is like we can't really do better than for consistency because it's always possible for the server to basically make a copy of the log and then from then on present different views to these clients. Now, s could not merge the two logs again, right. These logs have to be separate for a and b because it's impossible for s to sort of take the logs, let them grow for a while, and then basically splice these two logs together. Again, because these entries protect all these preceding entries, these entries protect all the preceding entries of those. And so you can't put them back together.", "metadataJson": "{\"start\":4309,\"end\":4352}"}, {"text": "And because the signatures wouldn't check out because the signatures always cover the current entry for all the preceding entries. And so the only thing that basically the server can do is basically split the world, fork the world into two different logs. They might have a common log in the beginning, then the server forks them. And now that a and b basically operate in different worlds.", "metadataJson": "{\"start\":4353,\"end\":4377}"}, {"text": "And that's sort of what the definition for consistency. And that is basically the best this particular file system, this particular system can do if the only communication actually happens between s.", "metadataJson": "{\"start\":4381,\"end\":4392}"}, {"text": "Notice actually, by the way, that sort of fork consistency is good enough for our particular application. Zookeeper. Correct. Because either the server shows the old version without a and b or the server shows the s, the modification with a and b.", "metadataJson": "{\"start\":4395,\"end\":4414}"}, {"text": "Okay, so what do you do now? It seems like, you know, maybe this is actually improper. You know, how do you do tech forex and how could you, so how do you detect force? Well, there's sort of two schemes that the sort of paper mentions. One is out of dance communication.", "metadataJson": "{\"start\":4417,\"end\":4440}"}, {"text": "And this is pretty straightforward. If a and b ever talk to each other and for example, ask each other, hey, what is your last entry in the log? And they get different answers. They know that they have been forked because either, okay, they could have different answers, but like at least one should be the prefix of the other. And if that's not the case, then they know that they're actually being, they have been forked.", "metadataJson": "{\"start\":4450,\"end\":4477}"}, {"text": "So that's one possible scenario that they discussed in the paper to basically share. The clients periodically exchanged the last log entries, the last entry in their logo. Another solution which actually has mentioned in the chat is introduce what they call sort of a trusted machine, that is a timestamp box. And basically every few seconds actually adds a timestamp to the log. And every client knows that maybe it's a file in the file system that just contains the current time.", "metadataJson": "{\"start\":4480,\"end\":4523}"}, {"text": "Every time the timestamp box, every couple of seconds the timestamp box updates that file. The clients read that file and they know there should be a new modification like every couple of seconds. And that basically that fork that contains the timestamp box is the fork that the server actually has to present to the clients.", "metadataJson": "{\"start\":4523,\"end\":4547}"}, {"text": "Okay, so that's the two things that actually the paper discusses. And what's sort of interesting and we'll see on Tuesday, is that this, you know, this whole fork detection and fork resolution approach is sort of a key problem basically in bitcoin. Correct. And when we talk on Tuesday about bitcoin, you know, we see a way basically to settle on a fork.", "metadataJson": "{\"start\":4551,\"end\":4573}"}, {"text": "So even if the file system or the servers, the byzantine servers, actually have created a forex, bitcoin basically has a way of deciding, well, we're going to reach the consensus on which forex we're going to actually proceed with. We'll leave that up until Tuesday. But here's a connection between sunder and actually bitcoin.", "metadataJson": "{\"start\":4575,\"end\":4598}"}, {"text": "Any questions about this?", "metadataJson": "{\"start\":4600,\"end\":4602}"}, {"text": "Okay. Okay. Now I want to talk very quickly because I have three minutes left about the other. So I think the key thing I get in the paper is this actually this log conceptual view of the world. Of course, you know, it's impractical, as I mentioned earlier.", "metadataJson": "{\"start\":4609,\"end\":4628}"}, {"text": "And so sumder actually has a proposal for how to do better, even though other systems like bitcoin actually do maintain the whole log. And so what does Sumner do? Two things better. Instead of actually maintaining a log that actually has snapshots similar to sort of the snapshots that we've seen before in raft, where we construct a part of the world based on the log, we take a snapshot and that actually forms the current state. In fact, really what the sonder does, it actually doesn't really make literally take snapshots.", "metadataJson": "{\"start\":4628,\"end\":4659}"}, {"text": "It really maintains a snapshot view of the file system. And does it per user.", "metadataJson": "{\"start\":4659,\"end\":4663}"}, {"text": "One way to think about it is that the file system is sharded by user. Every user has its own view snapshot of the world. And there's a little bit of a protocol to make sure that these different snapshots from different users are actually consistent. Let me talk a little bit about how actually sumder actually makes that snapshot. Basically, in Sumner.", "metadataJson": "{\"start\":4666,\"end\":4691}"}, {"text": "In Sumner, basically there's something that's called the user eye handle. And the user eye handle basically uniquely identifies snapshot in the file system. And basically it's a cryptographic hash of the itable, which includes all the inodes in the system. And you know, and for every inode there's a hash of the inode which basically covers all the data, all the blocks belonging to that particular inode. So for example, when, say a modifies off py, it might write one block, the client recomputes the hash of this block, updates the entry here, updates the entry here, updates the entry here.", "metadataJson": "{\"start\":4695,\"end\":4735}"}, {"text": "And that's basically a new handle that describes basically the captures the complete file system. I'm going to ignore the group and the directory block for a second. So this basically gives you a complete checkpoint or snapshot of user two's view of the file system.", "metadataJson": "{\"start\":4735,\"end\":4754}"}, {"text": "And then to deal with this issue of how to get sort of consistency across users, they have this notion of version vectors.", "metadataJson": "{\"start\":4757,\"end\":4766}"}, {"text": "What a version vector is pretty straightforward. Every version vector has an eye handle, like a's eye handle is in it after it modified, say, auth ui. And then for every user in the system the version vector has a counter for the number of modifications that were made by that user. So if a made this update to auth ui, that counter is set to one. B didn't make any modifications, C didn't make any modifications, they're all zero and this whole thing is signed.", "metadataJson": "{\"start\":4773,\"end\":4806}"}, {"text": "So when B makes its modifications. So here's the version vector for B. This is a version factor. So B makes a version, it creates a new handle that includes of course all the modifications or represent all the modifications. And in its version handle it actually, or in its version vector it includes which, how many operations it read by end user.", "metadataJson": "{\"start\":4809,\"end\":4831}"}, {"text": "So it will record the fact, for example, that it actually saw Ace modification. It updates b to b one and c to be zero and basically signs this whole thing.", "metadataJson": "{\"start\":4831,\"end\":4842}"}, {"text": "And now c, when C actually does an operation, wants to read auth Py and fetch the bank py, it basically downloads all the version vectors from every user. In this case it will get the version vectors for a, and b takes the latest one, which in this case is b because actually it includes all the operations of a in it. And that's basically the represented version of the file system. And from that version it reads auth Py and bank Pui.", "metadataJson": "{\"start\":4844,\"end\":4881}"}, {"text": "And note that basically it's impossible for the server to basically present banked up UI and not after py because you know it cannot, you know it can. The only two sort of version vectors it can return is this version vector or this version vector. The version vector a doesn't include actually the changes of bank BPY if, you know, c actually does get the versions of bank B two y and must actually have the versions, the modification that a has made because the version vectors are constructing in that way. And so that's basically the way for using version vectors to detect that s doesn't drop changes as we, as the same way that the logging system is done. Okay?", "metadataJson": "{\"start\":4884,\"end\":4932}"}, {"text": "So that's the essence of the version vector plan.", "metadataJson": "{\"start\":4932,\"end\":4934}"}, {"text": "So in summary, okay, byzantine participants are sort of a problem that you have to handle in decentralized systems because there's no single institution that sort of can be used source of trust. And we've seen this notion of signed logs as a very powerful tool to deal with malicious servers. And as I said on Tuesday, we're going to continue this discussion and you'll see how the design logs are used in bitcoin in particular, like how fork consistency or how the fact that forks are sort of being created are being resolved in the case of bitcoin. So that was it for an introduction to decentralized systems. And I hope the paper is a little bit more understandable than maybe before you start reading it earlier this week or today.", "metadataJson": "{\"start\":4937,\"end\":5003}"}, {"text": "Okay, see you on Tuesday. And, of course, if there's questions, please feel free to hang around if you need to go somewhere else. Absolutely. Go somewhere else. I have a question about the data structure that they used.", "metadataJson": "{\"start\":5003,\"end\":5019}"}, {"text": "B plus tree or whatever. Like, what's the difference between that and, like. Yeah, like. Like a Merkle dag, for example. Oh, it is a Merkle data structure.", "metadataJson": "{\"start\":5019,\"end\":5029}"}, {"text": "You know, I think the person who sort of credited with his id is Merkel, and that's why often it's called the Merkel data tree. So this is the same thing. Yeah. Okay. Yeah.", "metadataJson": "{\"start\":5030,\"end\":5044}"}, {"text": "Sunder basically uses a merkle tree.", "metadataJson": "{\"start\":5044,\"end\":5046}"}, {"text": "Sorry. When you are verifying the signatures, does it mean you have to, like, basically, as you go, if you are 100 entries into the log, you have to compute the hash of all the 100 entries concatenated. And then. Computer. Yeah.", "metadataJson": "{\"start\":5052,\"end\":5074}"}, {"text": "So you need to keep it running. Hash. Okay, let's go back to verify.", "metadataJson": "{\"start\":5075,\"end\":5078}"}, {"text": "So here's probably a good place to talk about it. So here. So let's say take the last entry. Correct.", "metadataJson": "{\"start\":5085,\"end\":5096}"}, {"text": "The last entry will have a hash of the preceding entries. So everything, you know, from the liker, whatever records, let's say this is zero, one, and two. You know, zero, one, and two, or basically has the hash of the previous entry number two in it. And that needs to be. That needs to be checked.", "metadataJson": "{\"start\":5098,\"end\":5122}"}, {"text": "And the way that is being checked is that, you know, in principle, if you start really, from the beginning of the world, and you would have to compute the hash with record zero, you find out what the hash is and double check that corresponds to the entry that's in here and that the signature is valid, et cetera, et cetera. Now, of course, in the real system, you can remember Moses, the log, and just double check that. Like, whatever, and start from there.", "metadataJson": "{\"start\":5122,\"end\":5153}"}, {"text": "Okay. So it's. It's inefficient. Okay. Yeah.", "metadataJson": "{\"start\":5155,\"end\":5159}"}, {"text": "You have to replay from the beginning of time. You basically have to really validate the whole log from the beginning of time.", "metadataJson": "{\"start\":5159,\"end\":5164}"}, {"text": "Thank you. That makes sense. Yeah. You'll see this in the bitcoin paper. Right.", "metadataJson": "{\"start\":5166,\"end\":5170}"}, {"text": "So are the hashes, like, almost like a merkel chain? Like. Yes. Okay. Same idea.", "metadataJson": "{\"start\":5170,\"end\":5177}"}, {"text": "So are the, like. If is the, like, leaf in the sort of tree or chain, like an entire file or, like, blocks of a file? This is a block, one block. So this is four, five, or 96 bytes.", "metadataJson": "{\"start\":5178,\"end\":5196}"}, {"text": "And all the other hashes don't change. Correct. So it's actually not that efficient. Inefficient. Yeah, because if you only change part of the file, it only rehashes that part.", "metadataJson": "{\"start\":5203,\"end\":5211}"}, {"text": "You just have to rehash that one and then you have to recompute the hash of the tree all the way to the user's eye handle.", "metadataJson": "{\"start\":5211,\"end\":5218}"}, {"text": "And the paper talks about sort of a couple optimizations to make this more efficient. But hashing is generally not that expensive. The signing is the more expensive part operation.", "metadataJson": "{\"start\":5222,\"end\":5231}"}, {"text": "I had a question about version vectors. Yeah. So we use version vectors to make sure that the system can't return like an old state. Yes. So why can't the, why can't the system just return the old state and the old version vector?", "metadataJson": "{\"start\":5238,\"end\":5249}"}, {"text": "If it keeps like a second copy. Yeah, it could fork. So we only have four consistency then with the reversion vector is only for consistency either. Thunder fork consistency, no more. Got it.", "metadataJson": "{\"start\":5249,\"end\":5261}"}, {"text": "You need the timestamp before consistency. I mean, you know, the server can fork the log at any particular point in time and present a consistent view of the log that can merge logs back together. So really this picture that the server can actually construct different views of the world and split the world in multiple worlds, but can merge the worlds back together undetectedly.", "metadataJson": "{\"start\":5268,\"end\":5304}"}, {"text": "So the best we can do is fork consistency, which allows for forking. But we can detect forking. Yeah. So if we detect forking, can we then get something stronger than fork consistency? Well, yep.", "metadataJson": "{\"start\":5307,\"end\":5321}"}, {"text": "Well we can settle on a fork. We're going to have forks, we can try to settle like pick one fork as the one to go forward with. Okay, but sunder doesn't have a way to do that. Nope. Okay, so it doesn't have to do that.", "metadataJson": "{\"start\":5322,\"end\":5336}"}, {"text": "I mean sundry does propose some, some methods, no, methods you detect and basically, you know, basically proposals like you use the timestamp box to use that one. Right.", "metadataJson": "{\"start\":5340,\"end\":5352}"}, {"text": "Thanks. You're welcome. The timestamp, the timestamp box is just a server that appends entries and. Yeah. And is trusted so it's not under control of the adversary.", "metadataJson": "{\"start\":5357,\"end\":5370}"}, {"text": "Thank you. Can I also ask one final question about the Debian example? You said in the beginning, can you say again what happened there? Yeah, sure. So basically the, this is the source repo development machines for Debian Linux.", "metadataJson": "{\"start\":5375,\"end\":5395}"}, {"text": "In 2003, attacker compromised, broke into those machines and modified files. And this is the distribution that has been sort of handed off which if you run Debian Linux, anybody who got the Debian lims after the attack got maybe a compromised Debian Linux. And so when as soon as they discovered this, they didn't do any further development, and there were further distributions. They sorted out, like, you know, went to backups, you know, started comparing files from backups with the files that they have, and, you know, basically double checked that. All the changes that were in the repo are actually really legit.", "metadataJson": "{\"start\":5395,\"end\":5436}"}, {"text": "Roll back and roll back. Any changes that are not legit.", "metadataJson": "{\"start\":5438,\"end\":5441}"}, {"text": "That is a pretty bad. Yeah, it's pretty bad. This occasionally happens. This is a real problem. It's a real problem in practice.", "metadataJson": "{\"start\":5443,\"end\":5451}"}, {"text": "Thank you so much. That was a very interesting lecture. Thank you. You're welcome. Thank you.", "metadataJson": "{\"start\":5452,\"end\":5457}"}]}